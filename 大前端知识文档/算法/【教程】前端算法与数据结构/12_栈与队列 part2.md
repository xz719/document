# 栈与队列 part2

上一节中，着重讲解的栈相关题目的常见解法，这一节我们就来学习队列的相关题目。

关于队列，在算法面试中大家需要掌握以下重点：

1. 栈向队列的转化
2. 双端队列
3. 优先队列

以上考点中，1 属于基础难度， 2 对一部分同学来说已经有点吃力，3 的区分度最高 --- 优先队列属于高级数据结构，其本质是二叉堆结构，考虑到相关题目具有较强的综合性，我们把它放在小册二叉树和堆相关的专题来展开。

## 1. 如何用栈实现一个队列？

```cmd
题目描述：使用栈实现队列的下列操作：
push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。

示例: MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek(); // 返回 1
queue.pop(); // 返回 1
queue.empty(); // 返回 false

说明:

你只能使用标准的栈操作 -- 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
```

### 1.1 💡思路解析

做这道题首先要清楚：栈和队列的区别在哪里？

仔细想想，栈，后进先出；队列，先进先出。也就是说两者的进出顺序其实是反过来的。用栈实现队列，说白了就是用栈实现先进先出的效果，再说直接点，就是想办法让栈底的元素首先被取出，也就是**让出栈序列被逆序**。

但栈结构决定了栈底元素只能被死死地压在最底下，如何使它首先被取出呢？既然一个栈做不到，那么我们用两个栈来做：

首先，准备两个栈：

[![pAsUNNQ.png](https://s21.ax1x.com/2024/11/05/pAsUNNQ.png)](https://imgse.com/i/pAsUNNQ)

既然要先将 1 取出，那么我们将这三个元素都转移到 stack2 中去，不就可以了吗：

[![pAsUd9s.png](https://s21.ax1x.com/2024/11/05/pAsUd9s.png)](https://imgse.com/i/pAsUd9s)

此时 1 变得触手可及。不仅如此，下一次我们试图出队 2 的时候，可以继续直接对 stack2 执行出栈操作 --- 因为转移 2 和 3 的时候已经做过一次逆序了，此时 stack2 的出栈序列刚好就对应队列的出队序列。

那么如果又有新元素入栈呢？

[![pAsU0cq.png](https://s21.ax1x.com/2024/11/05/pAsU0cq.png)](https://imgse.com/i/pAsU0cq)

要知道，既然实现的是队列，那么这个 4 一定要在 1、2、3 的后面取出，所以，当 4 需要被取出时，stack2 中的所有元素一定已经被取出了，即 stack2 为空。所以**当 stack2 为空、而 stack1 不为空时，我们需要继续把 stack1 中的元素转移到 stack2 中去**，然后再从 stack2 里取元素。也就是说，所有的出队操作都只能依赖 stack2 来完成——只要我们坚持这个原则，就可以确保 stack1 里的元素都能够按照正确的顺序（逆序）出栈。

总结一下，就是：

1. 元素入栈时，首先存入 stack1 中。
2. 当 stack2 为空时，将 stack1 中的所有元素转移至 stack2 中。
3. 需要取出元素时，从 stack2 中取。

### 1.2 编码实现

```js
/**
 * 初始化构造函数
 */
const MyQueue = function () {
  // 初始化两个栈
  this.stack1 = [];
  this.stack2 = [];
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function (x) {
  // 直接调度数组的 push 方法
  this.stack1.push(x);
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function () {
  // 若 stack2 为空，则将 stack1 中的所有元素转移
  if (!this.stack2.length) {
    while (this.stack1.length > 0) {
      this.stack2.push(this.stack1.pop());
    }
  }
  // 从 stack2 顶部取出元素
  return this.stack2.pop();
};

/**
 * Get the front element.
 * @return {number}
 * 这个方法和 pop 唯一的区别就是没有将定位到的值出栈
 */
MyQueue.prototype.peek = function () {
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length != 0) {
      // 将 stack1 出栈的元素推入 stack2
      this.stack2.push(this.stack1.pop());
    }
  }
  // 返回 stack2 顶部元素，若没有则返回 false
  const stack2Len = this.stack2.length;
  return stack2Len && this.stack2[stack2Len - 1];
};

/**
* Returns whether the queue is empty.
* @return {boolean}
*/
MyQueue.prototype.empty = function () {
  // 若 stack1 和 stack2 均为空，那么队列空
  return !this.stack1.length && !this.stack2.length;
};
```

## 2. 认识 `双端队列`

双端队列衍生出的滑动窗口问题，是一个经久不衰的命题热点。关于双端队列，各种各样的解释五花八门，这里大家不要纠结，就记住一句话：

❗**双端队列就是允许在队列的两端进行插入和删除的队列。**

体现在编码上，最常见的载体是既允许使用 `pop`、`push` 同时又允许使用 `shift`、`unshift` 的数组。

## 3. 滑动窗口问题

```cmd
题目描述：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]

解释: 滑动窗口的位置
---------------
[1 3 -1] -3 5 3 6 7
1 [3 -1 -3] 5 3 6 7
1 3 [-1 -3 5] 3 6 7
1 3 -1 [-3 5 3] 6 7
1 3 -1 -3 [5 3 6] 7
1 3 -1 -3 5 [3 6 7]

最大值分别对应：
3 3 5 5 6 7

提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。
```

### 3.1 💡思路解析：双指针 + 遍历（实际上是模拟）

这道题如果只是为了做对，那么思路其实不难想，我们直接模拟题中描述的这个过程就行。
按照题意，它要求我们在遍历数组的过程当中，约束一个窗口——窗口的本质其实就是一个范围，像这样：

```js
[1  3  -1] -3  5  3  6  7 
```

我们前面学过，约束范围，可以用 `双指针`。因此我这里定义一个 left 左指针、定义一个 right 右指针，分别指向窗口的两端即可：

[![pAsaA8s.png](https://s21.ax1x.com/2024/11/05/pAsaA8s.png)](https://imgse.com/i/pAsaA8s)

接下来我们可以把这个窗口里的数字取出来，直接遍历一遍、求出最大值，然后把最大值存进结果数组。这样第一个窗口的最大值就有了。

接着按照题意，窗口每次前进一步（左右指针每次一起往前走一步），此时的范围变成了这样：

[![pAsaeK0.png](https://s21.ax1x.com/2024/11/05/pAsaeK0.png)](https://imgse.com/i/pAsaeK0)

我们要做的仍然是取出当前范围的所有元素、遍历一遍求出最大值，然后将最大值存进结果数组。

反复执行上面这个过程，直到数组完全被滑动窗口遍历完毕，我们也就得到了问题的答案。

基于这个淳朴的思路，我们可以实现如下：

### 3.2 编码实现：双指针 + 遍历

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
const maxSlidingWindow = function (nums, k) {
  // 缓存数组的长度
  const len = nums.length;
  // 定义结果数组
  const res = [];
  // 初始化左指针
  let left = 0;
  // 初始化右指针
  let right = k - 1;
  // 当数组没有被遍历完时，执行循环体内的逻辑
  while (right < len) {
    // 计算当前窗口内的最大值
    const max = calMax(nums, left, right);
    // 将最大值推入结果数组
    res.push(max);
    // 左指针前进一步
    left++;
    // 右指针前进一步
    right++;
  }
  // 返回结果数组
  return res;
};

// 这个函数用来计算最大值
function calMax(arr, left, right) {
  // 处理数组为空的边界情况
  if (!arr || !arr.length) {
    return;
  }
  // 初始化 maxNum 的值为窗口内第一个元素
  let maxNum = arr[left];
  // 遍历窗口内所有元素，更新 maxNum 的值
  for (let i = left; i <= right; i++) {
    if (arr[i] > maxNum) {
      maxNum = arr[i];
    }
  }
  // 返回最大值
  return maxNum;
}
```

### 3.3 解法分析

现在我们来思考一下，上面这一波操作下来，时间复杂度是多少？

这波操作里其实涉及了两层循环，外层循环是 `while`，它和滑动窗口前进的次数有关。滑动窗口前进了多少次，`while` 就执行了多少次。

假设数组的规模是 `n`，那么从起始位置开始，滑动窗口每次走一步，一共可以走 `n - k`  次。注意别忘了初始位置也算作一步的，因此一共走了 `n - k + 1` 次。然后每个窗口内部我们又会固定执行 `k` 次遍历。注意 `k` 可不是个常数，它和 `n` 一样是个变量。因此这个时间复杂度简化后用大 O 表示法可以记为 `O(kn)`。

`O(kn)` 虽然不差，但对这道题来说，还不是最好。那么，如何优化？

### 3.4 💡思路分析：双端队列

要想变 `O(kn)` 为 `O(n)`，我们就要想怎么做才能丢掉这个 k。

k 之所以会产生，是因为我们现在只能通过遍历来更新最大值。那么更新最大值，有没有更高效的方法呢？

当滑动窗口往后前进一步的时候，比如我从初始位置前进到第二个位置：

[![pAsaXoF.png](https://s21.ax1x.com/2024/11/05/pAsaXoF.png)](https://imgse.com/i/pAsaXoF)

此时滑动窗口内的元素少了一个 1，增加了一个 -3，减少的数不是当前最大值，增加的数也没有超越当前最大值，因此最大值仍然是 3。此时我们不禁要想：如果我们能在窗口发生移动时，只**根据发生变化的元素对最大值进行更新**，那复杂度是不是就低很多了？

双端队列可以完美地帮助我们达到这个目的。

使用双端队列法，核心的思路是**维护一个有效的递减队列**（这一点在上一节中也经常出现）。

在遍历数组的前期，我们尝试将遍历到的每一个元素都推入队列内部。每尝试推入一个元素前，都把这个元素与队列尾部的元素作对比。根据对比结果的不同，采取不同的措施：

* 如果试图推入的元素（当前元素）大于队尾元素，则意味着队列的递减趋势被打破了。此时我们需要将队列尾部的元素依次出队（注意由于是双端队列，所以队尾出队是没有问题的）、直到队尾元素大于等于当前元素为止，此时再将当前元素入队。

* 如果试图推入的元素小于队列尾部的元素，那么就不需要额外的操作，直接把当前元素入队即可。

维持递减队列的目的，就在于**确保队头元素始终是当前窗口的最大值**。

当遍历到的元素个数达到了 k 个时，意味着滑动窗口的第一个最大值已经产生了，我们把它 push 进结果数组里：

[![pAsdVFe.png](https://s21.ax1x.com/2024/11/05/pAsdVFe.png)](https://imgse.com/i/pAsdVFe)

接下来，每往前遍历一个元素，都需要重复以上的几个步骤。这里我总结一下每一步都做了什么：

1. 检查队尾元素，看是不是都满足大于等于当前元素的条件。如果是的话，直接将当前元素入队。否则，从队尾开始逐个执行 `pop`、直到队尾元素大于等于当前元素为止。
2. 将当前元素的索引 `push` 进入双端队列
3. 检查队头元素，看队头元素是否已经被排除在滑动窗口的范围之外了。如果是，则将队头元素出队。
4. 判断滑动窗口的状态：看当前遍历过的元素个数是否小于 k。如果元素个数小于k，这意味着第一个滑动窗口内的元素都还没遍历完、第一个最大值还没出现，此时我们还不能动结果数组，只能继续更新队列；如果当前遍历过的元素个数大于等于k，这意味着滑动窗口的最大值已经出现了，此时每遍历到一个新元素（也就是滑动窗口每往前走一步）都要及时地往结果数组里添加当前滑动窗口对应的最大值（最大值就是此时此刻双端队列的队头元素）。

这四个步骤分别有以下的目的：

1. 维持队列的递减性：确保队头元素是当前滑动窗口的最大值。这样我们每次取最大值时，直接取队头元素即可。
2. 这一步没啥好说的，就是在维持队列递减性的基础上、更新队列的内容。
3. 维持队列的有效性：确保队列里所有的元素都在滑动窗口圈定的范围以内。
4. 排除掉滑动窗口还没有初始化完成、第一个最大值还没有出现的特殊情况。

结合以上的分析，我们来写代码：

### 3.5 编码实现：双端队列法

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
const maxSlidingWindow = function (nums, k) {
  // 缓存数组长度 + 初始化结果数组
  const len = nums.length;
  let res = [];

  // 初始化双端队列
  const deque = [];

  // 遍历数组
  for (let i = 0; i < len; i++) {
    // 将当前元素与队尾元素比较，保证双端队列的递减性
    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }
    // 将元素索引入队
    deque.push(i);
    // 检查队头元素是否已经在滑动窗口之外
    while (deque.length && deque[0] < i - k + 1) {
      // 在窗口之外的元素要被去除
      deque.shift();
    }
    // 检查滑动窗口状态，是否已经遍历了 k 个元素，如果是，则开始填入结果
    if (i >= k - 1) {
      res.push(nums[deque[0]])
    }
  }

  // 返回结果数组
  return res;
};
```

## ⏸️Tips

在上一节和这一节中，都反复出现了需要维护一个递减的栈或队列的情况，实际上，当题目中涉及到大小关系时，我们都可以采用**维护一个递增/递减的栈或队列**的方法来解决。
