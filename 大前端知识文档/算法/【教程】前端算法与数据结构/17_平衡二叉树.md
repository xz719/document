# 平衡二叉树

二叉搜索树是二叉树的特例，平衡二叉树则是二叉搜索树的特例。

## 什么是平衡二叉树？

在上一节的末尾，我们已经通过一道真题和平衡二叉树打过交道。正如题目中所说，平衡二叉树（又称 AVL Tree）指的是**任意结点的左右子树高度差绝对值都不大于 1** 的二叉搜索树。

## 为什么要有平衡二叉树？

平衡二叉树的出现，是为了降低二叉搜索树的查找时间复杂度。

大家知道，对于同样一个遍历序列，二叉搜索树的造型可以有很多种。拿 `[1,2,3,4,5]` 这个中序遍历序列来说，基于它可以构造出的二叉搜索树就包括以下两种造型：

[![pA2PuK1.png](https://s21.ax1x.com/2024/11/15/pA2PuK1.png)](https://imgse.com/i/pA2PuK1)

[![pA2PKDx.png](https://s21.ax1x.com/2024/11/15/pA2PKDx.png)](https://imgse.com/i/pA2PKDx)

结合平衡二叉树的定义，我们可以看出，第一棵二叉树是平衡二叉树，第二棵二叉树是普通的二叉搜索树。

现在，如果要你基于上一节学过的二叉搜索树查找算法，在图上两棵树上分别找出值为 1 的结点，问你各需要查找几次？在 1 号二叉树中，包括根结点在内，只需要查找 3 次；而在 2 号二叉树中，包括根结点在内，一共需要查找 5 次。

大家可以仔细想想，为什么要给二叉树的左右子树和根结点之间强加上排序关系作为约束，进而创造出二叉搜索树这种东西呢？难道只是为了装x吗？当然不是。二叉搜索树的妙处就在于它**把【二分】这种思想以数据结构的形式表达了出来**。在一个构造合理的二叉搜索树里，我们可以通过对比当前结点和目标值之间的大小关系，缩小下一步的搜索范围（比如只搜索左子树或者只搜索右子树），进而规避掉不必要的查找步骤，降低搜索过程的时间复杂度。但是如果一个二叉搜索树严重不平衡，比如说上面这棵链式搜索树：

[![pA2PKDx.png](https://s21.ax1x.com/2024/11/15/pA2PKDx.png)](https://imgse.com/i/pA2PKDx)

每一个结点的右子树都是空的，这样的结构非常不合理，它会带来高达 `O(N)` 的时间复杂度。而平衡二叉树由于利用了二分思想，查找操作的时间复杂度仅为 `O(logN)`。因此，为了保证二叉搜索树能够确实为查找操作带来效率上的提升，我们有必要在构造二叉搜索树的过程中维持其平衡度，这就是平衡二叉树的来由。

## 命题思路解读

平衡二叉树和二叉搜索树一样，都被归类为“特殊”的二叉树。对于这样的数据结构来说，其“特殊”之处也正是其考点所在，因此真题往往稳定地分布在以下两个方向：

* 对特性的考察（本节以平衡二叉树的判定为例）
* 对操作的考察（本节以平衡二叉树的构造为例）

### 1. 平衡二叉树的判定

```cmd
题目描述：给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1: 给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7

返回 true 。

示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4

 返回 false 。
```

#### 1.1 💡思路分析

既然是考察判断，那么就从定义入手。

> 平衡二叉树是任意结点的左右子树高度差绝对值都不大于 1 的二叉搜索树。

关键在于：

1. 任意结点
2. 左右子树的高度差绝对值都不大于 1
3. 二叉搜索树

当然，这里由于题目中只要求高度平衡，所以第三点暂时不用关心。

来看 1、2，既然是任意结点，那么就存在一个重复的逻辑，即：一棵树的左右子树高度差绝对值不大于 1，且其左右子树也满足这个条件。

既然是重复的逻辑，就要联想到 ---【递归】！

* 递归式：计算树的左右子树高度，得到左右子树高度的差值，判断是否小于 1
* 递归边界：存在子树高度差值大于 1/所有子树都满足条件

#### 1.2 编码实现

```js
const isBalanced = function (root) {
  // flag，一旦出现不满足的子树，就说明不是高度平衡二叉树
  let flag = true;

  // 递归方法，计算树的高度
  function dfs(root) {
    // 边界：如果当前树为空树，或者之前已经有不满足的子树了，则直接返回 0
    if (!root || !flag) {
      return 0;
    }

    // 计算左子树高度
    let left = dfs(root.left);
    // 计算右子树高度
    let right = dfs(root.right);

    // 比较左右子树高度
    if (Math.abs(left - right) > 1) {
      flag = false;
      // 后续不需要再判断了，及时停止
      return 0;
    }

    return Math.max(left, right) + 1;
  }

  // 开始递归
  dfs(root);

  return flag;
};
```

### 2. 平衡二叉树的构造（二叉搜索树 -> 平衡二叉树）

```cmd
题目描述：给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。
如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是平衡的。
如果有多种构造方法，请你返回任意一种。

示例：
```

[![pA2iNYF.png](https://s21.ax1x.com/2024/11/15/pA2iNYF.png)](https://imgse.com/i/pA2iNYF)

```cmd
输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。

提示：
树节点的数目在 1 到 10^4 之间。 树节点的值互不相同，且在 1 到 10^5 之间。
```

#### 2.1 💡思路分析

在上一节的最后，我们也尝试过平衡二叉树的构造，但是当时我们是直接将一个有序数组转化为平衡二叉树。

那么这两道题会不会有什么联系呢？

回想一下二叉搜索树的特性：二叉搜索树的中序遍历是一个有序数组！

这不就联系起来了吗？如果能把中序遍历序列求出来，这道题是不是就跟之前做过那道是一模一样的解法了？所以，这道题的求解思路就是：

1. 中序遍历求出有序数组
2. 逐个将二分出来的数组子序列“提”起来变成二叉搜索树


#### 2.2 编码实现

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
const balanceBST = function (root) {
  // 1. 求二叉搜索树的中序序列
  let mid = [];
  inorder(root);

  // 2. 由有序序列得到平衡二叉树
  return buildAVL(0, mid.length - 1);

  // 工具函数1：二叉树的中序遍历序列
  function inorder(root) {
    if (!root) {
      return;
    }
    inorder(root.left);
    mid.push(root.val);
    inorder(root.right);
  }

  // 工具函数2：将有序序列转化为平衡二叉树
  function buildAVL(low, high) {
    // 如果 low > high，则说明当前序列已经处理完毕
    if (low > high) {
      return null;
    }

    // 否则，通过 low 和 high 找到序列的中间元素，将其作为根节点
    let mid = Math.floor(low + (high - low) / 2);
    let root = new TreeNode(mid[mid]);
    // 根据左右序列继续构造左右子树
    root.left = buildAVL(low, mid - 1);
    root.right = buildAVL(mid + 1, high);

    return root;
  }
};
```