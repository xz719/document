# 了解递归 - 二叉树的递归遍历

## 二叉树的遍历

二叉树的遍历，就是以一定的顺序规则，逐个访问二叉树的所有结点。按照顺序规则的不同，遍历方式有以下4种：

1. 先序遍历
2. 中序遍历
3. 后序遍历
4. 层次遍历

按照实现方式的不同，遍历方式又可以分为2种：

* 递归遍历（先、中、后序遍历）
* 迭代遍历（层次遍历）

这里先不讨论层次遍历，而是放到后续的真题归纳环节中去。这里我们主要讲递归遍历，其也是前端算法面试的热门考察点之一。

### 初见递归遍历

> 编程语言中，当函数直接或间接地调用函数本身，则称该函数为递归函数。

我们之前说过，二叉树的定义就是一个**递归式的定义**：如果我们想要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止。

结合这个认知来看，每一棵二叉树都应该由这三部分组成：

* 根结点
* 左子树
* 右子树

而对二叉树的遍历，就是对这三个部分的遍历。那么我们应该先遍历这三个部分中的哪一个呢？

实际上，假如在保证“左子树一定先于右子树遍历”这个前提，那么遍历的可能顺序也不过三种：

* 根结点 -> 左子树 -> 右子树
* 左子树 -> 根结点 -> 右子树
* 左子树 -> 右子树 -> 根结点

上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。

在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。

所谓的先序、中序和后序，先、中、后其实就是指**根结点的遍历时机**。

### 遍历方法图解以及编码实现

#### 1. 先序遍历

根据上面的了解，先序遍历实际上就是：`根结点 -> 左子树 -> 右子树` 的过程。如果说树的高度为2，那么我们的遍历过程就如下图所示：

![1](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec42acc57e04~tplv-t2oaga2asx-jj-mark:1512:0:0:0:q75.awebp)

那么我们在程序中如何实现这个重复的过程呢？当然是递归了。

下面给出一个二叉树：

```js
const root = {
    val: "A",
    left: {
        val: "B",
        left: {
            val: "D",
            left: {},
            right: {}
        },
        right: {
            val: "E",
            left: {},
            right: {}
        }
    },
    right: {
        val: "C",
        left: {},
        right: {
            val: "F",
            left: {},
            right: {}
        }
    }
}
```

#### ⏸️注意：递归函数的要点

在开始编写一个递归函数之前，我们首先需要明确两样东西：

* 递归式
* 递归边界

【递归式】，它指的是你**每一次重复的内容是什么**。具体到先序遍历中，我们要重复的就是 `根结点 -> 左子树 -> 右子树` 这个过程。

【递归边界】，它指的是什么时候停下来。在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。这个“画句号”的方式，在编码实现里对应着一个 return 语句 —— 这就是二叉树遍历的递归边界。

#### ▶️继续实现

既然上面已经理清了思路，下面就是实现了：

```js
function preOrder (root) {
    // 边界：树为空
    if (!root || !Object.keys(root).length) {
        return;
    }

    // 递归式
    // 遍历根结点
    console.log('当前遍历结点的值为：', root.val);
    // 遍历左子树
    preOrder(root.left);
    // 遍历右子树
    preOrder(root.right);
}
```

下面我们一步步地来理清遍历的每一步都做了什么：

...(省略)

输出如下：

```js
当前遍历的结点值是： A
当前遍历的结点值是： B
当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： C
当前遍历的结点值是： F
```

#### 2. 中序遍历

理解了先序遍历，实现中序遍历就不是什么难事了，只不过将遍历的顺序变为：`左子树 -> 根结点 -> 右子树`。

![2](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714f098b2bd1f9a~tplv-t2oaga2asx-jj-mark:1512:0:0:0:q75.awebp)

递归的边界不变，那么实现如下：

```js
function inOrder (root) {
    // 边界：树为空
    if (!root || !Object.keys(root).length) {
        return;
    }

    // 递归式
    // 遍历左子树
    inOrder(root.left);
    // 遍历根结点
    console.log('当前遍历结点的值为：', root.val);
    // 遍历右子树
    inOrder(root.right);
}
```

最终输出内容如下：

```js
当前遍历的结点值是： D
当前遍历的结点值是： B
当前遍历的结点值是： E
当前遍历的结点值是： A
当前遍历的结点值是： C
当前遍历的结点值是： F
```

#### 3. 后序遍历

同样地，将遍历顺序换为：`左子树 -> 右子树 -> 根结点`：

![3](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714efce7db2cdff~tplv-t2oaga2asx-jj-mark:1512:0:0:0:q75.awebp)

实现如下：

```js
function postOrder (root) {
    // 边界：树为空
    if (!root || !Object.keys(root).length) {
        return;
    }

    // 递归式
    // 遍历左子树
    postOrder(root.left);
    // 遍历右子树
    postOrder(root.right);
    // 遍历根结点
    console.log('当前遍历结点的值为：', root.val);
}
```

输出内容如下：

```js
当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： B
当前遍历的结点值是： F
当前遍历的结点值是： C
当前遍历的结点值是： A
```

## 补充：树的遍历

上面仅仅讨论了二叉树的遍历，这里我想做一点补充：树的遍历。

在上一节中，我补充了 js 中树的实现方式和其结构：

```js
let tree = {
    id: '1',
    title: '节点1',
    children: [
        {
            id: '1-1',
            title: '节点1-1',
            children: [],
        },
        {
            id: '1-2',
            title: '节点1-2',
            children: [],
        }
    ]
}
```

同样地，树的遍历方式也可以分为2种：

* 广度优先遍历
* 深度优先遍历

其中**深度优先遍历是可递归的**，而**广度优先遍历是非递归的**，通常用**循环**来实现。深度优先遍历又分为先序遍历、后序遍历，实现方法可以是递归，也可以是循环。

广度优先和深度优先的概念很简单，区别如下：

* **深度优先**，访问完一颗子树再去访问后面的子树，而访问子树的时候，先访问根再访问根的子树，称为先序遍历；先访问子树再访问根，称为后序遍历。
* **广度优先**，即访问树结构的第 n+1 层前必须先访问完第 n 层

### 广度优先遍历的实现

广度优先的思路是，维护一个**队列**，队列的初始值为**树结构根节点组成的列表**，重复执行以下步骤直到队列为空：

* 取出队列中的第一个元素，进行访问相关操作，然后将其后代元素（如果有）全部追加到队列最后。

下面是代码实现，类似于数组的 forEach 遍历，我们将数组的访问操作交给调用者自定义，即一个回调函数：

```js
// 广度优先
function treeForeach (tree, func) {
    // 维护一个队列
    let queue = [tree];
    let node;

    // 遍历
    while (node = list.shift()) {
        // 读取当前结点
        func(node);
        // 将当前结点的所有子结点放入队列中
        node.children && list.push(...node.children);
    }
}
```

用上面的数据测试一下：

```js
> 节点1
> 节点1-1
> 节点1-2
```

可以看到，第一层的所有元素都在第二层元素的前面输出。

### 深度优先遍历的递归实现

先序遍历，很简单，递归式为先遍历结点，再遍历其子树。递归边界为其子树为空树。

实现如下：

```js
function treeForeach (tree, func) {
    
}
```

同理，后序遍历：

```js
function treeForeach (tree, func) {
    
}
```

用上面的例子测试一下：

```js
// 先序遍历


// 后序遍历

```

### 深度优先遍历的循环实现

...

### 更多树结构的操作

<https://www.cnblogs.com/ming1025/p/13677512.html>
