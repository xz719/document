# 链表的应用

链表结构相对数组、字符串来说，稍微有那么一些些复杂，所以针对链表的真题戏份也相对比较多。

前面咱们说过，数组、字符串若想往难了出，那一定是要结合一些超越数据结构本身的东西——比如**排序算法**、**二分思想**、**动态规划思想**等等。因此，这部分对应的难题、综合题，我们需要等知识体系完全构建起来之后，在真题训练环节重新复盘。

但是链表可不一样了。如果说在命题时，数组和字符串的角色往往是【算法思想的载体】，那么链表本身就可以被认为是【命题的目的】。单在真题归纳解读环节，我们能讲的技巧、能做的题目已经有很多。结合实际面试中的命题规律，我把这些题目分为以下三类：

* 链表的处理：合并、删除等（删除操作画个记号，重点中的重点！）
* 链表的反转及其衍生题目
* 链表成环问题及其衍生题目

本节我们就以链表的处理为切入点，一步一步走进链表的世界。

## 链表的合并

```cmd
真题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。

示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4
```

### 💡思路分析

做链表处理类问题，大家要把握住一个中心思想 —— ❗处理链表的本质，是处理**链表结点之间的指针关系**。

比如这道题，假设我们有下面两个链表：

[![pAr9Yse.png](https://s21.ax1x.com/2024/11/02/pAr9Yse.png)](https://imgse.com/i/pAr9Yse)

注意题目中的【两个有序链表】，自然联想到 `双指针`，而且由于链表中本身就是通过引用的方式链接的，所以我们实际上可以直接用两个链表的头节点来作为双指针。

### 编码实现

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
const mergeTwoLists = function (l1, l2) {
  // 新链表的头节点
  const head = new ListNode();
  // cur 用于标识新链表的尾部
  let cur = head;
  // 将 l1 和 l2 作为双指针遍历两个链表, 直到其中一个链表被遍历完（指针指向 null）
  while (l1 && l2) {
    if (l1.val <= l2.val) {
      // 将较小的节点加入新链表
      cur.next = l1;
      // l1 向左移
      l1 = l1.next;
    } else {
      // 将较小的节点加入新链表
      cur.next = l2;
      // l2 向左移
      l2 = l2.next;
    }
    // 新链表长度增加，cur 向后移
    cur = cur.next;
  }

  // 遍历完成后，若还存在未遍历完的内容，则直接将其链接到新链表后面
  cur.next = l1 ? l1 : l2;

  return head.next;
};
```

## 链表结点的删除

这一点前面在复习数据结构阶段已经讲解过...

## 删除问题的延伸 —— `dummy结点`

```cmd
真题描述：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。

示例 1:
输入: 1->2->3->3->4->4->5
输出: 1->2->5
示例 2:
输入: 1->1->1->2->3
输出: 2->3
```

### 💡思路分析

先来分析一下这道题和一般的删除链表重复元素有什么异同：相同的地方比较明显，都是删除重复元素。不同的地方在于，一般删到没有重复元素就行了，可以留个“独苗”；但现在，题干要求我们只要一个元素发生了重复，就要把它从链表中彻底删除，一个不留。

这带来了一个什么问题呢？回顾一下正常怎么删除重复元素的：在遍历的过程中判断当前结点和后继结点之间是否存在值相等的情况，若有，直接对后继结点进行删除：

[![pAr9Rds.png](https://s21.ax1x.com/2024/11/02/pAr9Rds.png)](https://imgse.com/i/pAr9Rds)

我们知道，**要删除链表中某一个目标结点时，必须知道它的前驱结点**。在上图中，我们本来就是站在前驱结点的位置，对其后继结点进行删除，只需要将前驱结点的 next 指针往后挪一位就行了。

但是现在，咱们要做的事情变成了把前驱和其后继一起删掉，前面两个值为1的结点要一起删去才行，起始结点直接变成了第三个：

[![pAr94J0.png](https://s21.ax1x.com/2024/11/02/pAr94J0.png)](https://imgse.com/i/pAr94J0)

其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 `dummy结点`来解决这个问题。

所谓 `dummy结点`，就是**人为制造出来的第一个结点的前驱结点**，这样**链表中所有的结点都能确保有一个前驱结点**，也就都能够用同样的逻辑来处理了。

dummy 结点能够帮助我们降低链表处理过程的复杂度，处理链表时，不设 dummy 结点思路可能会打不开；设了 dummy 结点的话，就算不一定用得上，也不会出错。

回到这道题上来，我们首先要做的就是定义一个 dummy 结点，指向链表的起始位置：

[![pAr9IzT.png](https://s21.ax1x.com/2024/11/02/pAr9IzT.png)](https://imgse.com/i/pAr9IzT)

这样一来，如果想要删除两个连续重复的值为 1 的结点，我们只需要把 dummy 结点的 next 指针直接指向 2：

[![pAr9TQU.png](https://s21.ax1x.com/2024/11/02/pAr9TQU.png)](https://imgse.com/i/pAr9TQU)

另外，在删除重复元素时，由于可能存在多个重复元素，我们可以用 while 循环进行判断和删除。

### 编码实现

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const deleteDuplicates = function (head) {
  // 优先判断：0个或1个结点，直接返回，不可能存在重复
  if (!head || !head.next) {
    return head;
  }
  // 1. 设置 dummy 结点，dummy 是头结点的前驱
  let dummy = new ListNode();
  dummy.next = head;

  // 2. 从 dummy 开始遍历链表，检查后续的两个结点
  let cur = dummy;
  // 检查后续两个结点是否存在重复，直到后续不存在两个结点
  while (cur.next && cur.next.next) {
    // 是否存在重复
    if (cur.next.val === cur.next.next.val) {
        // 若存在重复，则从第一个后继开始，一边删除重复结点一边继续判断
        let val = cur.next.val;
        while(cur.next && cur.next.val === val) {
            cur.next = cur.next.next;
        }
    } else {
        // 否则，cur 向后移动
        cur = cur.next;
    }
  }

  return dummy.next;
};
```

## ⏸️小结

1. 处理链表的本质 --- 处理链表结点之间的指针关系
2. `dummy结点` --- **人为制造出来的第一个结点的前驱结点**，确保**链表中所有的结点都能有一个前驱结点**，从而用同样的逻辑来处理所有结点。
