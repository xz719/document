# 动态规划 part1

## 1. “爬楼梯”问题

```cmd
题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶

示例 2：
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

### 1.1 💡思路分析与编码实现

这道题目有两个关键的**特征**：

1. 要求你给出达成某个目的的解法个数
2. 不要求你给出每一种解法对应的具体路径

这样的问题，往往可以用动态规划进行求解（这个结论先记下来，后面我们会有很多验证它的机会）。

#### 1.1.1 递归思想分析问题

基于动态规划的思想来做题，我们首先要想到的思维工具就是【倒着分析问题】，分两步走：

1. 定位到问题的终点
2. 站在终点这个视角，思考后退的可能性

在这道题里，“问题的终点”指的就是走到第 n 阶楼梯这个目标对应的**路径数**，我们把它记为 `f(n)`。

那么站在第 n 阶楼梯这个视角， 有哪些后退的可能性呢？按照题目中的要求，一次只能后退 1 步或者 2 步。因此可以定位到从第 n 阶楼梯只能后退到第 n - 1 或者第 n - 2 阶。我们把抵达第 n - 1 阶楼梯对应的路径数记为 `f(n-1)`，把抵达第 n - 2 阶楼梯对应的路径数记为 `f(n-2)`。

思考一下，能够走到第 n - 1 阶楼梯的路径，即 `f(n-1)` 中的路径，只要再往上走一步，不就是能够走到第 n 阶楼梯的路径了吗？

同理，能够走到第 n - 2 阶楼梯的路径，只要再往上走两步，不就也是能够走到第 n 阶楼梯的路径了？

```cmd
❓为什么可以直接相加？不会出现重复吗？

✨不会，因为对于 f(n-1) 中的路径来说，要走到第 n 阶台阶，必须再向上走一阶，而对于 f(n-2) 中的路径来说，则需要向上一步走两阶，这一步就决定了这些路径绝不会重复！
```

所以，我们可以得到以下关系：

```cmd
f(n) = f(n-1) + f(n-2)
```

将这一关系用树型图来表示更加形象：

[![pAW1R39.png](https://s21.ax1x.com/2024/11/20/pAW1R39.png)](https://imgse.com/i/pAW1R39)

现在我们不难看出，要想求出 `f(n)`，必须求出 `f(n-1)` 和 `f(n-2)`（我们假设 n 是一个大于 5 的数字）。

接下来站在第 n - 1 阶台阶上，思考后退的姿势，也无非只能是退到 n - 1 - 1 层台阶 或 n - 1 - 2 层台阶上，所以 `f(n-1)` 和 `f(n-2)`、`f(n-3)` 间同样具有以下关系：

```cmd
f(n-1) = f(n-2) + f(n-3)
```

同理，将 `f(n-2)` 也进行划分：

```cmd
f(n-2) = f(n-3) + f(n-4)
```

那么我们就能够得到下面的树型结构：

[![pAW15B6.png](https://s21.ax1x.com/2024/11/20/pAW15B6.png)](https://imgse.com/i/pAW15B6)

随着拆分的进行，一定会有一个时刻，求解到了 `f(1)` 或 `f(2)`。按照题设规则，第 1 阶楼梯只能走 1 步抵达，第 2 阶楼梯可以走 1 步或者走 2 步抵达，因此我们不难得出 `f(1)` 和 `f(2)` 的值：

```cmd
f(1) = 1   
f(2) = 2
```

我们在学习递归与回溯思想的时候，曾经给大家强调过，遇到“树形思维模型”，就要想办法往递归上靠。这道题明显用到了树形思维模型，有着明确的重复内容（不断地按照 `f(n) = f(n-1) + f(n-2)` 的规则拆分），同时有着明确的边界条件（遇到 `f(1)` 或 `f(2)` 就可以返回了），因此我们不难写出其对应的递归解法代码：

```js
/**
* @param {number} n
* @return {number}
*/
const climbStairs = function(n) {
    // 处理递归边界
    if(n === 1) {
        return 1
    }
    if(n === 2){
        return 2
    }
    // 递归计算
    return climbStairs(n-1) + climbStairs(n-2)
};
```

但是这个解法问题比较大，丢进 OJ 会直接超时。我们一起来看看原因，回到我们上面这张树形结构图上来：

[![pAW1H4e.png](https://s21.ax1x.com/2024/11/20/pAW1H4e.png)](https://imgse.com/i/pAW1H4e)

不难看出，我们在图中对 `f(n-2)` 和 `f(n-3)` 进行了**重复的计算**（注意是重复的计算，而不是重复的路径！）。事实上，随着我们递归层级的加深，这个重复的问题会越来越严重：

[![pAW1q9H.png](https://s21.ax1x.com/2024/11/20/pAW1q9H.png)](https://imgse.com/i/pAW1q9H)

#### 1.1.2 通过记忆化搜索提效

重复计算带来了时间效率上的问题，要想解决这类问题，最直接的思路就是**用空间换时间**，也就是想办法记住之前已经求解过的结果。这里我们只需要定义一个数组：

```js
const f = []
```

每计算出一个 `f(n)` 的值，都把它塞进 `f` 数组里。下次要用到这个值的时候，直接取出来就行了：

```js
/**
* @param {number} n
* @return {number}
*/
// 定义记忆数组 f
const f = []
const climbStairs = function(n) {
  if(n==1) {
      return 1
  }
  if(n==2) {
      return 2
  }
  // 若f[n]不存在，则进行计算
  if(f[n]===undefined)  f[n] = climbStairs(n-1) + climbStairs(n-2)
  // 若f[n]已经求解过，直接返回
  return f[n]
};
```

以上这种在递归的过程中，**不断保存已经计算出的结果，从而避免重复计算**的手法，叫做【记忆化搜索】。

但严格来说，记忆化搜索和动态规划是两个东西，并不能一概而论，所以我们下面试试动态规划的解法。

#### 1.1.3 记忆化搜索 -> 动态规划

要想完成记忆化搜索与动态规划之间的转化，首先要清楚两者间的区别。

先说记忆化搜索，记忆化搜索可以理解为**优化过后的递归**。递归往往可以基于树形思维模型来做，以这道题为例：

[![pAW3pE8.png](https://s21.ax1x.com/2024/11/20/pAW3pE8.png)](https://imgse.com/i/pAW3pE8)

我们基于树形思维模型来解题时，实际上是站在了一个比较大的未知数量级（也就是最终的 n），来不断进行拆分，最终拆回较小的已知数量级（`f(1)`、`f(2)`）。这个过程是一个明显的**自顶向下**的过程。

动态规划则恰恰相反，是一个**自底向上**的过程。它要求我们站在**已知**的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值。

在这道题中，已知 `f(1)` 和 `f(2)` 的值，要求解未知的 `f(n)`，我们唯一的抓手就是这个等价关系：

```cmd
f(n) = f(n-1) + f(n-2)
```

以 `f(1)` 和 `f(2)` 为起点，不断求和，循环递增 n 的值，我们就能够求出 `f(n)` 了：

```js
/**
* @param {number} n
* @return {number}
*/
const climbStairs = function(n) {
    // 初始化状态数组
    const f = [];
    // 初始化已知值
    f[1] = 1;
    f[2] = 2;
    // 动态更新每一层楼梯对应的结果
    for(let i = 3;i <= n;i++){
        f[i] = f[i-2] + f[i-1];
    }
    // 返回目标值
    return f[n];
};
```

以上便是这道题的动态规划解法。

### 1.2 从题解思路看动态规划

下面我们基于这个题解的过程，站在专业的角度来重新认识一下动态规划。

前面咱们在排序专题学过【分治】思想，提到了【子问题】这个概念。分治问题的核心思想是：

> 把一个问题分解为**相互独立**的子问题，逐个解决子问题后，再组合子问题的答案，就得到了问题的最终解。

【动态规划】的思想和【分治】有点相似。不同之处在于，【分治】思想中，各个子问题之间是**独立**的：比如说归并排序中，子数组之间的排序并不互相影响。而【动态规划】划分出的子问题，往往是**相互依赖、相互影响**的。

❗什么样的题应该用动态规划来做？我们要抓以下两个关键特征：

* 最优子结构
* 重叠子问题

拿这道题的分析过程来说：

[![pAW1q9H.png](https://s21.ax1x.com/2024/11/20/pAW1q9H.png)](https://imgse.com/i/pAW1q9H)

**最优子结构**，它指的是【问题的最优解包含着子问题的最优解】 --- 不管前面的决策如何，此后的状态必须是基于当前状态（由上次决策产生）的最优决策。就这道题来说，`f(n)` 和 `f(n-1)`、`f(n-2)` 之间的关系印证了这一点（这玩意儿叫**状态转移方程**，可以记一下）。

**重叠子问题**，它指的是【在递归的过程中，出现了反复计算的情况】。就这道题来说，图上标红的一系列重复计算的结点印证了这一点。

因此，这道题适合用动态规划来做。

## 2. 动态规划问题的分析技巧

现在，大家理解了动态规划的概念，明确了其“自底向上”的脑回路特征。但在实际做题过程中，“自底向上”分析问题往往不是最舒服的解题方向。

拿上面爬楼梯的问题来说，前面递归 + 记忆化搜索的思路用起来明显要直接用动态规划轻松的多，**树形思维模型将帮助我们更迅速地定位到状态转移关系，边界条件往往对应的就是已知子问题的解**，最后再结合记忆化搜索，就能够解决问题。

但递归 + 记忆化搜索的思路终归只能帮助我们简化思路，不能完全解决问题，最后还是得靠自己分析。

动态规划类题目，往往有以下几个难点：

1. 状态转移方程不好确定
2. 已知的状态可能不明显
3. 递归转化迭代

总结一下，对于动态规划，可以优先选择这样的分析路径：

1. 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系；
2. 结合记忆化搜索，明确状态转移方程；
3. 递归代码转化为迭代表达（这一步不一定是必要的，第一、二步本身为思维路径，而并非代码实现。如果足够熟练，第二步中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。

## 3. “最值”型问题典范：如何优雅地找硬币

```cmd
题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例1：
输入: coins = [1, 2, 5], amount = 11
输出: 3
解释: 11 = 5 + 5 + 1

示例2：
输入: coins = [2], amount = 3
输出: -1
```

❗提示：最值问题是动态规划的常见对口题型，见到最值问题，应该想到动态规划

### 3.1 💡思路分析

要明确状态转移关系，我们依然是借助“倒推”的思想：解决爬楼梯问题时，我们首先思考的是站在第 n 阶楼梯上的后退姿势。这道题也一样，我们需要思考的是站在 `amount` 这个组合结果上的“后退姿势” --- 我们可以假装此时手里已经有了 36 美分，只是不清楚硬币的个数，把“如何凑到 36”的问题转化为“如何从 36 减到 0”的问题。

我们这里用 c1、c2、c3......cn 分别来表示题目中给到我们的第 1 至 n 个硬币。现在我如果从 36 美分的总额中拿走一个硬币，那么有以下几种可能：

```cmd
拿走 c1
拿走 c2
拿走 c3
......
拿走 cn
```

重复往前推导这个“拿走”的过程，我们可以得到以下的树形思维模型：

[![pAW8nsI.png](https://s21.ax1x.com/2024/11/20/pAW8nsI.png)](https://imgse.com/i/pAW8nsI)

其中， `f(x)` 表示**每一个总额数字对应的最少硬币数**，那么我们可以得到以下的对应关系：

```cmd
f(36) = Math.min(f(36-c1)+1,f(36-c2)+1,f(36-c3)+1......f(36-cn)+1)
```

```cmd
❓为什么？

✨首先明确，f(n) 是指每个总额所对应的最少硬币数，一定要牢记最少！然后看 f(36 - c1)，其代表拿掉 c1 后总额所对应的最少硬币数，那如果我们将 c1 放回去，即 f(36 - c1) + 1，不就是总额 36 的一种组合方式吗？同理这样考虑其他硬币，然后再在其中取最小，不就拿到了总额 36 对应的最少硬币数吗。另外，由于 f(36 - c1) 代表拿掉 c1 后总额所对应的最少硬币数，其本身也是最优，这不就是最优之上再取最优吗，所以这个关系是能够成立的。
```

找出了状态转移方程，我们接下来需要思考的是递归的边界条件：在什么情况下，我的“后退”（实际是做减法）可以停下来？这里需要考虑的是**硬币总额为 0** 的情况，这种情况对应的硬币个数毫无疑问也会是 0，因而不需要任何的回溯计算。由此我们就得到了一个已知的最基本的子问题的结果：

```js
f[0] = 0
```

现在，明确了状态转移方程，明确了已知子问题的解，我们来写代码：

### 3.2 编码实现

```js
const coinChange = function (coins, amount) {
  // 用于保存每个目标总额对应的最小硬币个数
  const f = [];
  // 提前定义已知情况
  f[0] = 0;
  // 遍历 [1, amount] 这个区间的硬币总额
  for (let i = 1; i <= amount; i++) {
    // 求的是最小值，因此我们预设为无穷大，确保它一定会被更小的数更新
    f[i] = Infinity;
    // 循环遍历每个可用硬币的面额
    for (let j = 0; j < coins.length; j++) {
      // 若硬币面额小于目标总额，则问题成立
      if (i - coins[j] >= 0) {
        // 状态转移方程
        f[i] = Math.min(f[i], f[i - coins[j]] + 1);
      }
    }
  }
  // 若目标总额对应的解为无穷大，则意味着没有一个符合条件的硬币总数来更新它，本题无解，返回-1
  if (f[amount] === Infinity) {
    return -1;
  }
  // 若有解，直接返回解的内容
  return f[amount];
};
```
