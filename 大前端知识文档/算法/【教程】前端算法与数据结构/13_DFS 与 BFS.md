# DFS 与 BFS

本节我们学习两种关键的基本算法思想：DFS（深度优先搜索）和BFS（广度优先搜索）。这两种算法和栈、队列有着千丝万缕的关系。

## 深度优先搜索思想（DFS）

深度优先搜索的核心思想，是**试图穷举所有的完整路径**。

## 深度优先搜索的本质 --- 栈结构

如何编码实现 DFS？

以迷宫问题为例，抽象后的迷宫结构如下：

[![pAsfIWq.png](https://s21.ax1x.com/2024/11/06/pAsfIWq.png)](https://imgse.com/i/pAsfIWq)

下面我们用深度优先的思想来走这个迷宫：

1. 从 A 出发，沿着唯一的一条道路往下走，遇到了第1个岔路口 B。眼前有三个选择：C、D、E。这里我按照从上到下的顺序来走（你也可以按照其它顺序），先走 C。
2. 发现 C 是死胡同，后退到最近的岔路口 B，尝试往 D 方向走。
3. 发现 D 是死胡同，，后退到最近的岔路口 B，尝试往 E 方向走。
4. E 是一个岔路口，眼前有两个选择：F 和 G。按照从上到下的顺序来走，先走 F。
5. 发现 F 是死胡同，后退到最近的岔路口 E，尝试往 G 方向走。
6. G 是一个岔路口，眼前有两个选择：H 和 I。按照从上到下的顺序来走，先走 H。
7. 发现 H 是死胡同，后退到最近的岔路口 G，尝试往 I 方向走。
8. I 就是出口，成功走出迷宫。

观察上述过程，会发现这个过程与我们栈结构的入栈、出栈非常相似，下面我们再用栈来模拟一遍：

1. 从 A 出发（ A 入栈），经过了 B（ B 入栈），接下来面临 C、D、E 三条路。这里按照从上到下的顺序来走（你也可以选择其它顺序），先走 C（ C 入栈）。
2. 发现 C 是死胡同，后退到最近的岔路口 B（ C 出栈），尝试往 D 方向走（ D 入栈）。
3. 发现 D 是死胡同，，后退到最近的岔路口 B（ D 出栈），尝试往 E 方向走（ E 入栈）。
4. E 是一个岔路口，眼前有两个选择：F 和 G。按照从上到下的顺序来走，先走 F（ F 入栈）。
5. 发现 F 是死胡同，后退到最近的岔路口 E（ F 出栈），尝试往 G 方向走（ G 入栈）。
6. G 是一个岔路口，眼前有两个选择：H 和 I。按照从上到下的顺序来走，先走 H（ H 入栈）。
7. 发现 H 是死胡同，后退到最近的岔路口 G（ H 出栈），尝试往 I 方向走（ I 入栈）。
8. I 就是出口，成功走出迷宫。

此时栈里面的内容就是A、B、E、G、I，因此 `A->B->E->G->I` 就是走出迷宫的路径。通过深度优先搜索，我们不仅可以定位到迷宫的出口，还可以记录下相关的路径信息。

现在大家知道了**深度优先搜索的过程可以转化为一系列的入栈、出栈操作**。那么深度优先搜索在编码上一般会如何实现呢？在 DFS 中，我们一般用**递归**来模拟入栈、出栈的过程。

## DFS 与二叉树的遍历

现在我们站在深度优先搜索的角度，重新理解一下**二叉树的先序遍历**过程：

[![pAshPOO.png](https://s21.ax1x.com/2024/11/06/pAshPOO.png)](https://imgse.com/i/pAshPOO)

从 A 结点出发，访问左侧的子结点；如果左子树同样存在左侧子结点，就头也不回地继续访问下去。一直到左侧子结点为空时，才退回到距离最近的父结点、再尝试去访问父结点的右侧子结点——这个过程，和走迷宫是何其相似！事实上，在二叉树中，结点就好比是迷宫里的坐标，图中的每个结点在作为父结点时无疑是岔路口，而空结点就是死胡同。我们回顾一下二叉树先序遍历的编码实现：

```js
// 所有遍历函数的入参都是树的根结点对象
function preorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return 
    }
     
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历左子树 
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}
```

因此，二叉树的先序遍历正是深度优先搜索思想的递归实现。可以说深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广。

但问题是，在二叉树的先序遍历中，完全没有栈的影子，那么为什么说 DFS 的本质是栈呢？

我们从两个角度来理解这个事情：

* 首先，函数调用的底层，仍然是由栈来实现的。JS 会维护一个叫【函数调用栈】的东西，`preorder` 每调用一次自己，相关调用的上下文就会被 `push` 进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被 `pop` 出来。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。
* 其次，DFS 作为一种思想，它和树的递归遍历一脉相承、却并不能完全地画上等号 --- DFS 的解题场景其实有很多，其中有一类会**要求我们记录每一层递归式里路径的状态**，此时就会强依赖栈结构。

## 广度优先搜索（BFS）--- 找到迷宫出口的另一种方式

继续考虑上面的迷宫问题：

[![pAsfIWq.png](https://s21.ax1x.com/2024/11/06/pAsfIWq.png)](https://imgse.com/i/pAsfIWq)

与深度优先搜索不同的是，广度优先搜索（BFS）并不执着于“一往无前”。它关心的是**眼下自己能够直接到达的所有坐标，其动作有点类似于“扫描”** --- 比如说站在 B 这个岔路口，它会只关注 C、D、E 三个坐标，至于 F、G、H、I 这些遥远的坐标，现在不在它的关心范围内。按照这个思路，广度优先搜索每次以【广度】为第一要务、雨露均沾，**一层一层地**扫描，最后也能够将所有的坐标扫描完全：

[![pAshefI.png](https://s21.ax1x.com/2024/11/06/pAshefI.png)](https://imgse.com/i/pAshefI)

按照 BFS 的遍历规则，具体的访问步骤会变成下面这样：

1. 站在入口A处（第一层），发现直接能抵达的坐标只有B，于是接下来需要访问的就是 B。
2. 入口 A 访问完毕，走到 B 处（第二层），发现直接能抵达的坐标变成了 C、D 和 E，于是把这三个坐标记为下一层的访问对象。
3. B 访问完毕，访问第三层。这里我按照从上到下的顺序（你也可以按照其它顺序），先访问 C 和 D，然后访问 E。站在 C 处和 D 处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。但是在 E 处见到了可以直接抵达的 F 和 G，因此把 F 和 G 记为下一层（第四层）需要访问的对象。
4. 第三层访问完毕，访问第四层。第四层按照从上到下的顺序，先访问的是 F。从 F 出发没有可以直接触达的坐标，因此不做额外的操作。接着访问 G，发现从 G 出发可以直接抵达 H 和 I，因此把 H 和 I 记为下一层（第五层）需要访问的对象。
5. 第四层访问完毕，访问第五层。第五层按照从上到下的顺序，先访问的是 H，发现从 H 出发没有可以直接抵达的坐标，因此不作额外的操作。接着访问 I，发现 I 就是出口，问题得解。

当然啦，这个问题若采用 BFS 的思路来解，那么它其实已经不能说是一个严格的迷宫游戏了 --- 在一个真正的迷宫游戏里，大概率并不会允许我们如此顺利地逐个访问身在同一层次的所有坐标（比如 C 和 D 之间可能就会隔了厚厚的一堵墙，导致你无法在访问 C 后直接去访问 D ）。这里我们基于迷宫游戏，抽象出来的其实是一个更为简单的模型。大家不必拘泥于游戏本身，而应该着重理解这个**分层遍历**的过程。

在分层遍历的过程中，大家会发现两个规律：

* 每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。
* 站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。

丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，因此整个 BFS 算法的实现过程，和**队列**有着密不可分的关系。

同样，我们可以用队列 queue 来模拟上面的过程：

1. 初始化，先将入口 A 入队（queue 里现在只有 A）。
2. 访问入口 A（第一层），访问完毕后将 A 出队。发现直接能抵达的坐标只有 B，于是将 B 入队（queue 里现在只有 B）。
3. 访问 B（第二层），访问完毕后将 B 出队。发现直接能抵达的坐标变成了 C、D和E，于是把这三个坐标记为下一层的访问对象，也就是把它们全部入队（queue 里现在是 C、D、E）
4. 访问第三层。这里我按照从上到下的顺序（你也可以按照其它顺序），先访问 C（访问完毕后 C 出队）和 D（访问完毕后 D 出队），然后访问 E（访问完毕后 E 出队）。访问 C 处和 D 处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。但是在 E 处我们见到了可以直接抵达的 F 和 G，因此把 F 和 G 记为下一层（第四层）需要访问的对象，F、G 依次入队（queue 里现在是 F、G）。
5. 访问第五层。第五层按照从上到下的顺序，先访问的是 H（访问完毕后 H 出队），发现从 H 出发没有可以直接抵达的坐标，因此不作额外的操作。接着访问 I（访问完毕后 I 出队），发现 I 就是出口，问题得解（此时 queue 队列已经被清空）。

## BFS --- 二叉树的层序遍历

...
