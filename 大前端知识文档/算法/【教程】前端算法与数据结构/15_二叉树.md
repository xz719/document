# 二叉树

在本节，有以下三个命题方向需要大家重点掌握：  

* 迭代法实现二叉树的先、中、后序遍历
* 二叉树层序遍历的衍生问题
* 翻转二叉树

这三个方向对应的考题都比较经典。与此同时，解决这些问题涉及到的思路和编码细节，也会成为各位日后解决更加复杂的问题的基石。

## 1. 迭代法实现二叉树的先、中、后序遍历

在[第五章](./4_二叉树遍历的三种方式.md)中，我们已经学习了二叉树的三种遍历方式，而在上一节中，我们也用递归的方式实现了先序遍历。

这里我们尝试用迭代法来实现一下二叉树的三种遍历方法，然后，我们可以回头与递归的实现方法比较一下，看看哪种实现方式更好。

### 1.1 先序遍历

```cmd
题目描述：给定一个二叉树，返回它的前序（先序）遍历序列。

示例: 
1   
 \   
  2   
 /  
3 

输出: [1,2,3]
```

#### 1.1.1 💡思路分析

前面两个小节，我们一直在强调，递归和栈有着脱不开的干系。当一道本可以用递归做出来的题，突然不许你用递归了，此时我们本能的反应，就应该是往栈上想。

题目中的出参是一个数组，大家仔细看这个数组，它像不像是一个栈的出栈序列？实际上，做这道题的一个根本思路，就是通过**合理地安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历规则。**

前序遍历的规则是，先遍历根结点、然后遍历左孩子、最后遍历右孩子——这正是我们所期望的出栈序列。

按道理，入栈序列和出栈序列相反，我们似乎应该按照 `右->左->根` 这样的顺序将结点入栈。不过需要注意的是，我们遍历的起点就是根结点，难道我们要假装没看到这个根结点、一鼓作气找到最右侧结点之后才开始进行入栈操作吗？答案当然是否定的，我们的出入栈顺序应该是这样的：  

1. 将根结点入栈
2. 若栈不为空，取出栈顶结点，将结点值 push 进结果数组
3. 若栈顶结点有右孩子，则将右孩子入栈
4. 若栈顶结点有左孩子，则将左孩子入栈

重复 2、3、4 步骤，直至栈空，我们就能得到一个先序遍历序列。

#### 1.2 编码实现

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const preorderTraversal = function (root) {
  // 结果数组
  const res = [];
  // 栈结构
  const stack = [];

  // 特殊情况：根节点为空
  if (!root) {
    return res;
  }

  // 先将根节点入栈
  stack.push(root);

  // 迭代
  while (stack.length) {
    // 1. 弹出栈顶元素，放入结果数组
    let top = stack.pop();
    res.push(top.val);

    // 2. 栈顶元素是否有右子树
    if (top.right) {
      stack.push(top.right);
    }

    // 3. 栈顶元素是否有左子树
    if (top.left) {
      stack.push(top.left);
    }
  }

  return res;
};
```

### 1.2 异曲同工的后序遍历迭代实现

#### 1.2.1 💡思路分析

后序遍历的出栈序列，按照规则应该是 `左 -> 右 -> 根` 。这个顺序相对于先序遍历，最明显的变化就是根结点的位置从第一个变成了倒数第一个。

如何做到这一点呢？与其从 stack 这个栈结构上入手，不如从 res 结果数组上入手：我们可以直接把 pop 出来的当前结点 unshift 进 res 的头部，改造后的代码会变成这样：

```js
while(stack.length) {
  // 将栈顶结点记为当前结点
  const cur = stack.pop() 
  // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部
  res.unshift(cur.val)
  // 若当前子树根结点有右孩子，则将右孩子入栈
  if(cur.right) {
    stack.push(cur.right)
  }
  // 若当前子树根结点有左孩子，则将左孩子入栈
  if(cur.left) {
    stack.push(cur.left)
  }
}
```

由于我们填充 res 结果数组的顺序是从后往前填充（每次增加一个头部元素），因此先出栈的结点反而会位于 res 数组相对靠后的位置。出栈的顺序是 `当前结点 -> 当前结点的左孩子 -> 当前结点的右孩子` ，其对应的 res 序列顺序就是 `右 -> 左 -> 根` 。这样一来， 根结点就成功地被我们转移到了遍历序列的最末尾。

现在只剩下这个右孩子和左孩子的顺序了，这两个孩子结点进入结果数组的顺序与其被 pop 出栈的顺序是一致的，而出栈顺序又完全由入栈顺序决定，因此只需要相应地调整两个结点的入栈顺序就好了：  

```js
// 若当前子树根结点有左孩子，则将左孩子入栈
if(cur.left) {
  stack.push(cur.left)
}  
// 若当前子树根结点有右孩子，则将右孩子入栈
if(cur.right) {
  stack.push(cur.right)
}
```

如此一来，右孩子就会相对于左孩子优先出栈，进而被放在 res 结果数组相对靠后的位置， `左 -> 右 ->根` 的排序规则就稳稳地实现出来了。

我们把以上两个改造点结合一下，就有了以下代码：

#### 1.2.2 编码实现

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const postorderTraversal = function(root) {
  // 定义结果数组
  const res = []  
  // 处理边界条件
  if(!root) {
      return res
  }
  // 初始化栈结构
  const stack = [] 
  // 首先将根结点入栈
  stack.push(root)  
  // 若栈不为空，则重复出栈、入栈操作
  while(stack.length) {
      // 将栈顶结点记为当前结点
      const cur = stack.pop() 
      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部
      res.unshift(cur.val)
      // 若当前子树根结点有左孩子，则将左孩子入栈
      if(cur.left) {
        stack.push(cur.left)
      }  
      // 若当前子树根结点有右孩子，则将右孩子入栈
      if(cur.right) {
        stack.push(cur.right)
      }
  }
  // 返回结果数组
  return res
};
```

### 1.3 思路清奇的中序遍历迭代实现

#### 1.3.1 💡思路分析

经过上面的讲解，大家会发现先序遍历和后序遍历的编码实现其实是非常相似的，它们遵循的都是同一套基本框架。那么我们能否通过对这个基本框架进行微调、从而同样轻松地实现中序遍历呢？

答案是不能，为什么？因为先序遍历和后序遍历之所以可以用同一套代码框架来实现，本质上是因为两者的出栈、入栈逻辑差别不大——都是先处理根结点，然后处理孩子结点。

而中序遍历中，根结点不再出现在遍历序列的边界、而是出现在遍历序列的中间。这就意味着无论如何我们不能再将根结点作为第一个被 pop 出来的元素来处理了。

中序遍历的序列规则是 `左 -> 中 -> 右` ，这意味着我们必须首先定位到最左的叶子结点。在这个定位的过程中，必然会途径目标结点的父结点、爷爷结点和各种辈分的祖宗结点.

途径过的每一个结点，我们都要及时地把它入栈。这样当最左的叶子结点出栈时，第一个回溯到的就是它的父结点：

[![pAg0wRO.png](https://s21.ax1x.com/2024/11/14/pAg0wRO.png)](https://imgse.com/i/pAg0wRO)

有了父结点，就不愁找不到兄弟结点，基于这个思路，我们来写代码：  

#### 1.3.2 编码实现

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const inorderTraversal = function(root) {
  // 定义结果数组
  const res = []  
  // 初始化栈结构
  const stack = []   
  // 用一个 cur 结点充当游标
  let cur = root  
  // 当 cur 不为空、或者 stack 不为空时，重复以下逻辑
  while(cur || stack.length) {
      // 这个 while 的作用是把寻找最左叶子结点的过程中，途径的所有结点都记录下来 
      while(cur) {
          // 将途径的结点入栈
          stack.push(cur)  
          // 继续搜索当前结点的左孩子
          cur = cur.left  
      }
      // 取出栈顶元素
      cur = stack.pop()  
      // 将栈顶元素入栈
      res.push(cur.val)  
      // 尝试读取 cur 结点的右孩子
      cur = cur.right
  }
  // 返回结果数组
  return res
};
```

### 1.4 总结

1. 前序遍历：控制树中节点入栈的顺序，通过出栈实现 `根 -> 左 -> 右` 的顺序；
2. 后序遍历：控制栈中节点进入 res 中的顺序（用 unshift 代替 push），以及左右子树入栈的顺序，来实现 `左 -> 右 ->根` 的顺序；
3. 中序遍历：**找树的最左节点，并将路径中的节点入栈**。对树本身以及树的所有子树重复上述逻辑！

## 2. 层序遍历的衍生问题

在 [DFS 和 BFS](./13_DFS%20与%20BFS.md) 这一节，我们已经讲过了二叉树层序遍历的实现方法：BFS 与队列。

对于这类问题，我们接下来会讲最有代表性的一道作为例题。

```cmd
题目描述：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：
  3
 / \
9  20
  /  \
 15   7

返回其层次遍历结果：
[
[3],
[9,20],
[15,7]
]
```

### 2.1 💡思路分析

层序遍历没有那么多幺蛾子，大家看到层序遍历就应该条件反射出 `BFS + 队列`  这对好友。所谓变体，不过是在 BFS 的过程中围绕结果数组的内容做文章。

拿这道题来说，相对于我们 14 节中讲过的层序遍历基本思路，它变出的花样仅仅在于要求我们对层序遍历结果进行**分层**。也就是说只要我们能在 BFS 的过程中感知到当前层级、同时用不同的数组把不同的层级区分开，这道题就得解了。

如何做到这一点？大家需要知道一个非常重要的信息：**我们在对二叉树进行层序遍历时，每一次 while 循环其实都对应着二叉树的某一层。**只要我们在进入while循环之初，记录下这一层结点个数，然后将这个数量范围内的元素 push 进同一个数组，就能够实现二叉树的分层。

### 2.2 编码实现

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const levelOrder = function(root) {
    // 初始化结果数组
    const res = []  
    // 处理边界条件
    if(!root) {
        return res
    }  
    // 初始化队列
    const queue = []   
    // 队列第一个元素是根结点
    queue.push(root)  
    // 当队列不为空时，反复执行以下逻辑
    while(queue.length) {
        // level 用来存储当前层的结点
        const level = []  
        // 缓存刚进入循环时的队列长度，这一步很关键，因为队列长度后面会发生改变
        const len = queue.length  
        // 循环遍历当前层级的结点
        for(let i=0;i<len;i++) {
            // 取出队列的头部元素
            const top = queue.shift()  
            // 将头部元素的值推入 level 数组
            level.push(top.val)
            // 如果当前结点有左孩子，则推入下一层级
            if(top.left) {
                queue.push(top.left)
            }
            // 如果当前结点有右孩子，则推入下一层级
            if(top.right) {
                queue.push(top.right)
            }
        }
        // 将 level 推入结果数组
        res.push(level)
    }
    // 返回结果数组
    return res
};
```

## 3. 翻转二叉树 --- 递归

翻转二叉树是一个非常经典的问题。翻转二叉树在算法面试中实在太常见了 --- 只要你准备算法面试，你就不得不做这个题。

```cmd
题目描述：翻转一棵二叉树。

示例：
     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1

```

### 3.1 💡思路分析

这道题是一道非常经典的递归应用题。

一棵二叉树，经过翻转后会有什么特点？答案是每一棵子树的左孩子和右孩子都发生了交换。既然是“每一棵子树”，那么就意味着重复，既然涉及了重复，就没有理由不用**递归**。

于是这道题解题思路就非常明确了：以递归的方式，遍历树中的每一个结点，并将每一个结点的左右孩子进行交换。

### 3.2 编码实现

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
const invertTree = function(root) {
    // 定义递归边界
    if(!root) {
        return root;
    }
    // 递归交换右孩子的子结点
    let right = invertTree(root.right);
    // 递归交换左孩子的子结点
    let left = invertTree(root.left);
    // 交换当前遍历到的两个左右孩子结点
    root.left = right;
    root.right = left;
    return root;
};
```
