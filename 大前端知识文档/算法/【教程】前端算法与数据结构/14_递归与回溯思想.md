# 递归与回溯思想

## 1. 全排列问题

```cmd
题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。

示例：   
输入: [1,2,3]
输出: [
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]
```

### 1.1 💡思路分析

首先了解全排列的概念：

> 从 n 个不同元素中任取 m（m≤n）个元素，按照一定的顺序排列起来，叫做从 n 个不同元素中取出 m 个元素的一个排列。当 m=n 时所有的排列情况叫全排列。

不了解也不要紧，根据题干以及示例不难看出，实际上就是要求以一个 n 个数的数组作为入参，穷举出这个 n 个数的所有排列方式。

既然是穷举，那么能不能用 DFS 来做呢？可以的话，怎么做呢？

先看看在这个变化的序列中，不变的是什么 --- 数的个数 n，拿示例来说，不管我怎么调整数字的顺序，它们都只能围着这 3 个数进行变化。**当我们感到变化难以把握时，不如尝试先从不变的东西入手**。

现在问题变成了，我手里有 3 个数，要往三个位置上填，有几种填法？很简单，`3 * 2 * 1` 种方法。可惜这道题问的不是全排列的可能性有多少种，而是要求你把每一种可能性都穷举出来。这其实有点类似于我们上一节玩迷宫游戏的时候，游戏规则不仅要求你回答出迷宫的通关方法有几种，还要求你列举出每一条路的路径。列举“路径”，我们首先要找到“坐标”。在这道题里，“坐标”就是每一个位置里可能填进的数字。

[![pAs4SEQ.png](https://s21.ax1x.com/2024/11/06/pAs4SEQ.png)](https://imgse.com/i/pAs4SEQ)

root 是一个空坐标，是我们分配数字的起点。现在我们要向第一个位置中填入一个数字，显然我们有三个选择：

[![pAs4gaQ.png](https://s21.ax1x.com/2024/11/06/pAs4gaQ.png)](https://imgse.com/i/pAs4gaQ)

继续，向第二个位置中填入一个数字，此时，根据第一步中填入数字的不同，第二个位置中有以下可能：

[![pAs425j.png](https://s21.ax1x.com/2024/11/06/pAs425j.png)](https://imgse.com/i/pAs425j)

接下来，最后一个位置，同样根据前面的填入情况有以下可能：

[![pAs5ERI.png](https://s21.ax1x.com/2024/11/06/pAs5ERI.png)](https://imgse.com/i/pAs5ERI)

可以看到，在不知不觉中，我们构建出了一个树结构！从这个树结构里我们可以清晰地看出，全排列的所有可能性。

但是需要注意，虽然我们在思考过程中构建出了树结构，并不意味着我们就需要在代码中真的使用树，这里我们真正需要的是**递归**。

在以上的思考过程中，我们重复地做了以下事情：  

1. 检查手里剩下的数字有哪些
2. 选取其中一个填进当前的坑里

这不就是我们的【递归式】吗？

❗Tip：以后只要分析出**重复的逻辑**（排除掉类似数组遍历这种简单粗暴的重复），你都需要联想到递归。只要想到递归，立刻联想到 DFS 思想，然后尝试套这一节最后给出的解题模板。这个脑回路未必 100% 准确，但确实有极高的成功概率。

继续，既然找到了递归式，那么接下来就要找到【递归边界】，很简单，当最后一个数字被填入最后一个位置时，递归就要停止了。

### 1.2 编码实现

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const permute = function(nums) {
  const len = nums.length;
  const cur = []; // 当前排列结果
  const visited = {}; // 在当前排列中，哪些数字已经被访问过，防止出现重复使用

  const res = []; // 结果数组

  // dfs 方法，入参为当前需要填入数字的位置
  function dfs (index) {
    // 边界：当 index = len 时，说明所有位置已经填完，可以将结果加入 res 中，并结束递归
    if (index === len) {
      res.push(cur.slice())
      return
    }

    // 递归式
    for (let i = 0; i < len; i++) {
      if (!visited[nums[i]]) {
        // 若当前数字没有被访问过，则将其加入当前排列中，并打上标记
        cur.push(nums[i]);
        visited[nums[i]] = 1;
        // 然后，根据当前排列，继续向下一个位置填入
        dfs(index + 1);
        // 填入完成后，将当前数字取出（这一条路线的深度遍历已经完成），下掉标记
        cur.pop();
        visited[nums[i]] = 0;
      }
    }
  }

  // 开始递归
  dfs(0);
  return res;
}
```

这段代码中有两个需要注意的地方：

1. Map 结构 `visited`  的使用：填坑时，每用到一个数字，我们都要给这个数字打上“已用过”的标 --- 避免它被使用第二次；数字让出坑位时，对应的排列和 `visited`  状态也需要被及时地更新掉。
2. 当走到递归边界时，一个完整的排列也到手了。将这个完整排列推入结果数组时，我们用了 `res.push(cur.slice())` 而不是简单的 `res.push(cur)` 。为什么这样做？因为全局只有一个唯一的 `cur` ， `cur` 的值会随着 dfs 的进行而不断被更新。 `slice` 方法的作用是帮助我们拷贝出一个不影响 `cur` 正本的副本，以防直接修改到 `cur` 的引用。

## 2. 组合问题

```cmd
题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
```

### 2.1 💡思路分析

前面说过，出现穷举的情况，要立即联想到 DFS、递归。既然要用递归，那么就要找递归式和递归边界。

我们仍然秉持一个原则：**当我们感到变化难以把握时，不如尝试先从不变的东西入手**。

在上一题中，变化的是数的填入顺序，不变的是排列的长度。那么这道题呢？显然每个组合中数字的个数是不同的，而数字的顺序无需考虑，那么剩下的不变的就只有参与组合的数字了。

其实也可以这样想，参与组合的数字是不变的，但它们在组合中的存在与否是变化的。因此我们的思路可以调整为，从每一个数字入手，讨论它出现或者不出现的情况：

[![pAs7JNF.png](https://s21.ax1x.com/2024/11/06/pAs7JNF.png)](https://imgse.com/i/pAs7JNF)

从 root 出发，每一个数字对应树的一层，存在或不存在对应树的两个分叉。从第一层到第三层，我们得到的所有完整路径，就是 3 个数的所有可能的组合形式。

既然思路有了，我们接下来就是要找到递归式与递归边界了：

* 递归式：检查剩余数字，选择是否将其填入组合。然后根据当前情况，继续查看下一个数字的存在与否；
* 递归边界：检查完数组中所有数字的存在与否后停止递归。

### 2.2 编码实现

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const subsets = function(nums) {
  const len = nums.length;
  const res = []; // 结果数组

  const subsets = []; // 当前组合数组

  dfs(0);

  // dfs 方法，以当前检查数字的下标为入参
  function dfs (index) {
    // 边界：遍历完所有数字，所以这里并不需要做处理，在 for 循环中就完成了边界的处理，这里只需要将组合加入到结果数组中
    res.push(subsets.slice())
    // 递归式
    for (let i = index; i < len; i++) {
      // 遍历剩下的数字（index 之前的数字都检查过了）
      // 将该数字填入，并继续检查下一个数字
      subsets.push(nums[i]);
      dfs(i + 1);
      // 不存在这个数字的情况
      subsets.pop();
    }
  }

  return res;
}
```

## 3. 限定组合问题：及时回溯，即为“剪枝”  

```cmd
题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]
```

### 3.1 💡思路分析

这是一道复杂化的组合问题，它追加了一个限定条件 --- 只返回 n 个数中 k 个数的组合。在普通的组合问题中，树形逻辑是这样的：

![Snipaste 2024 11 06 12 55 35](https://img.z4a.net/images/2024/11/06/Snipaste_2024-11-06_12-55-35.png)

而在这道题里要求我们只输出其中的一部分。假如 n = 3， k = 2，那么需要输出的内容就如下图的红色箭头所示：

![Snipaste 2024 11 06 12 56 57](https://img.z4a.net/images/2024/11/06/Snipaste_2024-11-06_12-56-57.png)

在遍历的过程中，一旦我们发现组合中的数字数量超过 2 个，就停止继续往深处搜索，这就意味着一些结点压根没有机会被遍历到。

这其实就是【剪枝】的过程 --- 在深度优先搜索中，有时我们会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案。这个丢掉答案的过程，形似剪掉树的枝叶，所以这一方法被称为【剪枝】。

要做到剪枝，我们需要分别在组合问题的递归式和递归边界上动手脚：

* 递归式：普通组合问题，每到一个新的坑位处，我们都需要对组合结果数组进行更新；这道题中，**当且仅当组合内数字个数为 k 个时，才会对组合结果数组进行更新**。
* 递归边界：只要组合内数字个数达到了 k 个，就**不再继续当前的路径往下遍历**，而是直接返回。

### 3.2 编码实现

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
const combine = function(n, k) {
  // 结果数组
  const res = [];

  // 当前组合
  const subset = []

  // dfs
  dfs(1);

  // dfs 方法
  function dfs (index) {
    // 边界：当且仅当组合内数字个数为 k 个时，才会对组合结果数组进行更新，且不再继续递归
    if (subset.length === k) {
      res.push(subset.slice())
      return
    }

    // 递归式
    // 1. 取所有剩余数字
    for (let i = index; i <= n; i++) {
      // 2. 对其中一个剩余数字进行二叉
      // 取该数字填入，根据填入后的结果，继续处理（右子树）
      subset.push(i);
      dfs(i + 1);
      // 不取该数字填入（左子树）
      subset.pop();
    }
  }

  return res;
}
```

## 何为 `回溯` ？

现在，或许你还暂时不知道何为“回溯算法”，但你其实已经实打实地在真题中对它有了具体的实践。基于这些实践，我们反过来理解一下回溯的概念：

> 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就 “回溯” 返回，尝试别的路径。
>
> 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为 “回溯点”。
>
> 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
>
> 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 —— LeetCode

字很多，我们重点关注这句话：“回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。” 这和上一节的 DFS 不是很像吗？

实际上，这里的“回溯”二字，大家可以理解为是在强调 DFS 过程中“退一步重新选择”这个动作。这样想的话，DFS 算法其实就是回溯思想的体现。

❗另外，我们并不需要纠结【回溯】的定义，反复纠结文字游戏，无法给你带来任何实质上的能力提升。

## ✨递归与回溯问题 --- 解题模板总结

### 什么时候用？

两个特征：

1. 题目中暗示了一个或多个解，并且要求我们**详尽地列举出每一个解的内容**时，一定要想到 `DFS`、`递归回溯`。  
2. 题目经分析后，可以转化为**树形逻辑模型**求解。

### 为什么这样用？

递归与回溯的过程，本身就是穷举的过程。题目中要求我们列举每一个解的内容，解从哪来？解是基于穷举思想、对搜索树进行恰当地剪枝后得来的。

❗Tip：这里需要大家注意到另一种问法：不问解的内容，只问**解的个数**。这类问题往往不用 DFS 来解，而是用 `动态规划`（我们后面会学）。这里，大家先记下这个辨析，对以后做题会有帮助。

### 怎么用？

* 一个模型 --- 树形逻辑模型；
* 两个要点 --- 递归式和递归边界。

树形逻辑模型的构建，关键在于找【坑位】，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为【坑位】数量的边界。

用伪代码总结一下编码形式，大部分的题解都符合以下特征：  

```js
function xxx(入参) {
  前期的变量定义、缓存等准备工作 
  
  // 定义路径栈
  const path = []
  
  // 进入 dfs
  dfs(起点) 
  
  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return   
    }
    
    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```
