# 字符串的应用

字符串在算法面试中，单独考察的机会并不多，同样倾向于和一些经典算法（后面会讲的）结合来体现区分度。本节我们照样是先解决只需要数据结构知识做基础就可以解决的字符串问题。

在做题之前，首先来看两个字符串相关的基本算法技巧，这两个技巧偶尔也会单独考察，但整体来看在综合性题目中考察频率较高，需要重点关注。

## 字符串的常用算法技巧

### 1. 反转字符串

在 js 中反转字符串比较简单，直接调用 api 就行：

```js
const str = 'reverse';

const res = str.split('').reverse().join('');
```

### 2. 判断一个字符串是否是回文字符串

回文字符串，就是正着读和倒着读都一模一样的字符串，比如这样的：

```js
'tenet'
```

回文字符串有两个特性：

* 反转后的回文字符串不变；
* 回文字符串具有 `对称性`；

依据这两个特性，我们可以分别写出两个判断回文字符串的方法，首先是利用反转字符串：

```js
function isPalindrome(str) {
    // 将原字符串反转
    let rev = str.split('').reverse().join('');
    // 将反转后的字符串与原字符串比较
    return rev === str;
}
```

然后是利用对称性，将回文字符串从中间劈开，会得到两个对称的子串：

```js
function isPalindrome(str) {
    let len = str.length;
    for (let i = 0; i < len / 2; i++) {
        // 将字符串从两端开始一位一位进行对比
        if (str[i] !== str[len - i - 1]) {
            return false;
        }
    }
}
```

注意这个对称的性质，非常容易用到。

## 🎯真题

### 1. 回文字符串衍生

```cmd
真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

示例 1: 输入: "aba"
输出: True
示例 2:
输入: "abca"
输出: True
解释: 你可以删除c字符。
注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。
```

#### 1.1 💡思路解析

首先我们考虑基本的解法，即遍历字符串，一个个删去然后看剩下的字符串是否是回文的。这样解肯定是没问题的，但是不够高效。

如何优化？考虑我们前面提到的回文字符串的两个特性，尤其是 `对称性`，既然验证对称性是从两端逐一比较，那能不能用 `双指针` 呢？当然可以，实际上，当题目里面出现【回文】时，我们就需要考虑 `对称性` 和 `双指针`。

首先我们设定两个指针 left 和 right，分别指向字符串的两端：

[![pADxhvQ.png](https://s21.ax1x.com/2024/11/02/pADxhvQ.png)](https://imgse.com/i/pADxhvQ)

如果两个指针所指的字符恰好相等，那么这两个字符就符合了回文字符串对对称性的要求，跳过它们往下走即可。如果两个指针所指的字符串不等，比如这样：

[![pADx5uj.png](https://s21.ax1x.com/2024/11/02/pADx5uj.png)](https://imgse.com/i/pADx5uj)

那么就意味着**不对称**发生了，意味着这是一个可以“删掉试试看”的操作点。我们可以分别对左指针字符和右指针字符尝试进行“跳过”，看看区间在 `[left+1, right]` 或 `[left, right-1]` 的字符串是否回文。如果是的话，那么就意味着如果删掉被“跳过”那个字符，整个字符串都将回文：

[![pADxobn.png](https://s21.ax1x.com/2024/11/02/pADxobn.png)](https://imgse.com/i/pADxobn)

比如说这里跳过 b，`[left+1, right]` 的区间就是 [2, 2]，它对应 c 这个字符，单个字符一定回文。这样一来，删掉 b 之后，左右指针所指的内部区间是回文的，外部区间也是回文的，可以认为整个字符串就是一个回文字符串了。

思路有了，下面进行实现。

#### 1.2 编码实现

```js
function validPalindrome (str) {
    let len = str.length;
    // 左右指针
    let left = 0;
    let right = len - 1;
    // 双指针法遍历字符串，直到出现不对称
    while (left < right && str[left] === str[right]) {
        left++;
        right++;
    }
    // 出现不对称
    // 1. 判断跳过左侧字符后，剩余字符是否回文
    if (isPalindrome(left + 1, right)) {
        return true;
    }

    // 2. 判断跳过右侧字符后，剩余字符是否回文
    if (isPalindrome(left, right - 1)) {
        return true;
    }
    
    // 3. 否则不符合
    return false;

    // ！！！工具方法，用于判断某一范围的字符串是否回文
    const isPalindrome = (start , end) => {
        while (start < end) {
            if (str[start] !== str[end]) {
                return false;
            }
        }
        return true;
    }
}
```

### 2. 字符串匹配问题 --- 正则表达式

```cmd
真题描述： 设计一个支持以下两种操作的数据结构：

1. void addWord(word)
2. boolean search(word)

search(word) 可以接收文字或正则表达式字符串，正则字符串只包含字母、'.'。'.' 可以表示任何一个字母。

示例: addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
说明:
你可以假设所有单词都是由小写字母 a-z 组成的。
```

这是一道综合性比较强的大题。

#### 2.1 💡思路解析

这道题要求字符串既可以被添加、又可以被搜索，这就意味着字符串在添加时一定要被存在某处。键值对存储，我们用 Map（或对象字面量来模拟 Map）即可。

另外，为了降低查找时的复杂度，我们可以以字符串的长度为 key，将相同长度的字符串存在一个数组中（**tip：空间换时间！**）。

难点在于 search 这个 API，它既可以搜索文字，又可以搜索正则表达式。因此我们在搜索前需要额外判断一下，传入的到底是普通字符串，还是正则表达式。若是普通字符串，则直接去 Map 中查找是否有这个 key；若是正则表达式，则创建一个正则表达式对象，判断 Map 中相同长度的字符串里，是否存在一个能够与这个正则相匹配。

这道题思路上倒是没有很多难点，但它考察的内容比较多。

#### 2.2 编码实现

```js
/**
 * 构造函数
 */
const WordDictionary = function () {
    // 初始化一个 Map
    this.words = new Map();
};

// addWord
WordDictionary.prototype.addWord = function (word) {
    // 若已经有对应长度的键，则直接加入 
    if (this.words.has(word.length)) {
        this.words[word.length].push(word);
    } else {
        // 否则新建
        this.words.set(word.length, [word]);
    }
}

// searchWord
WordDictionary.prototype.searchWord = function (str) {
    // 优先判断：map 中是否有对应长度的键，没有则不必继续搜索
    if (!this.words.has(str.length)) {
        return false;
    }

    // 判断传入的是文字还是正则字符串
    // 1. 传入文字
    if (!str.includes('.')) {
        return this.words[str.length].includes(str);
    }

    // 2. 传入正则字符串
    const reg = new RegExp(str);
    return this.words[str.length].some((w) => {
        return reg.test(w);
    })
}
```

### 3. 正则表达式更进一步 —— 字符串与数字之间的转换问题

```cmd
真题描述：请你来实现一个 atoi 函数，使其能将字符串转换成整数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。

示例 1:
输入: "42"
输出: 42

示例 2:
输入: " -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。

示例 3: 输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。

示例 4: 输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。

示例 5:
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。
```

#### 3.1 💡思路解析

首先解析题干：

1. 该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止  —— 解析字符串时先去空格；

2. 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的**连续数字**组合起来，作为该整数的正负号 —— 接下来识别开头的 `+` 字符和 `-` 字符，然后找后续的连续数字；

3. 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响 —— 即遇到非整数字符就可以停止转换了；

4. 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31)，所以我们需要判断数值是否超过这个范围。

另外，题目中还明确说了当：

* 当第一个有效字符不是 `+` 字符和 `-` 字符或数字时；
* 当字符串为空
* 字符串仅包含空白字符

时不进行转换。

所以，我们的第一步就是

##### step1：计算边界值

```js
// 计算最大值
const max = Math.pow(2,31) - 1
// 计算最小值
const min = -max - 1
```

##### step2：解析字符串

接下来，需要解析字符串，这里更推荐用**正则**来做，原因很简单：当看到题目里有这么密集的字符串约束条件，作为前端，本能地是能想到用正则来做的；同时，正则表达式本身就是前端面试中的一个基础知识点，如果一道题能够同时考察字符串操作和正则表达式，其实也正中了面试官的下怀。

对于正则表达式，大多数的团队不会有特别强硬的要求，不会期望你一定要多么多么精通、能不靠 Google 徒手写多么复杂的表达式出来啥的——这样搞其实也没有意义。但是必要的基础你是要有的，这道题目涉及到的正则其实就在这个“必要”的范围里，我们一起来分析一下，首先是看回这三个约束条件：

1. 该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止 —— 允许字符串头部出现空格，但是在处理的时候要想办法把它摘出去，不要让它干扰计算；

2. 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号 —— 允许字符串的第一个有效字符为 `+` 或者 `—`，不要摘出去，它对计算是有意义的；

3. 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响 —— 匹配的时候，连续整数之外的部分都应该被摘除；

首先需要去除空格，一种方法是利用 js 原生的 trim 方法，它可以用于去除字符串首尾的空格：

```js
const str = '   wda  ';

console.log(str.trim()); // wda
```

另一种方法，是在匹配的时候，匹配空格（正则匹配符为 `\s*`，意味着匹配 0 个或多个空格），但是不把它放在【捕获组】里 —— 这种方法会更加通用，正则表达式匹配过程中，所有的“摘除”动作都可以通过将匹配到的结果排除在捕获组之外来实现。

什么是【捕获组】？其实就是**正则表达式中被小括号括住的部分**。捕获组中的内容，会在调用 `String.match` 方法且非全局匹配（正则表达式后没有 `g` 标识）时，被放入结果数组中。

在这道题里，我们需要从字符串中提取的其实只有 `+/-` 符号以及其后面的数字而已，同时这个字符串需要满足 可能存在的 `空格 + 正负号 + 数字字符串 + 其它字符内容` 这样的格式才算合法，那我们就可以通过这样写正则表达式，实现“匹配”和“提取”的双重目的：

```js
/\s*([-\+]?[0-9]*).*/
```

这个正则表达式的意思是：

* `\s` 这个符号，意味着空字符，它可以用来匹配回车、空格、换行等空白区域，这里，它用来被匹配空格。`*` 这个符号，跟在其它符号后面，意味着前面这个符号可以出现0次或多次。`\s*`，这里的意思就是空格出现 0 次或多次，都可被匹配到。
* 接着 `()` 出现了。`()` 圈住的内容，就是我们要捕获起来额外存储的东西。
* `[]` 中的匹配符之间是“或”的关系，也就是说只要能匹配上其中一个就行了。这里 `[]` 中包括了 `-`和 `\+`，`-` 不必说匹配的是对应字符，**这个 `\+` 之所以加了一个斜杠符，是因为 `+` 本身是一个有特殊作用的正则匹配符**，这里我们要让它回归 `+` 字符的本义，所以要用一个 `\` 来完成转义。
* `[0-9]*` 结合咱们前面铺陈的知识，这个就不难理解了，它的意思是 0-9 之间的整数，能匹配到 0 个或多个就算匹配成功。
* 最后的 `.` 这个是任意字符的意思，`.*` 用于字符串尾部匹配非数字的任意字符。我们看到 `.*` 是被排除捕获组之外的，所以说这个东西其实也不会被额外存储，它被“摘除”了。

##### step3：获取捕获结果

前面我们说到过，【捕获组】中的内容，会在调用 `String.match` 方法且非全局匹配时，被放入结果数组中。所以，我们直接从结果数组中获取捕获结果即可：

```js
const reg = /\s*([-\+]?[0-9]*).*/
const groups = str.match(reg)
```

`match()` 方法用于在字符串中执行查找匹配的字符串，它返回一个数组，在未匹配到时会返回 null。如果我们的正则表达式尾部有 `g` 标志，`match()` 会返回与完整正则表达式匹配的所有结果，**但不会返回捕获组**。

这里我们没有使用 `g` 标志，`match()` 就会返回第一个完整匹配（作为数组的第0项）及其相关的捕获组（作为数组的第1及第1+项）。

##### step4：判断转换后的数字是否超过上下限

这一步不必多说，前面已经将上下限计算好了。

#### 3.2 编码实现

```js
const customizedAtoi = function (str) {
  // 1. 计算上下限
  let max = Math.pow(2, 31) - 1;
  let min = -max - 1;

  // 2. 编写正则，匹配得到捕获组
  const reg = /\s*([-\+]?[0-9]*).*/;
  const groups = str.match(reg);

  // 3. targetNum 用于存储转化出来的数字
  let targetNum = 0;
  // 如果匹配成功
  if (groups) {
    // 尝试转化捕获到的结构
    targetNum = +groups[1];
    // ！！！注意，即便成功，也可能出现非数字的情况，比如单一个'+'
    if (isNaN(targetNum)) {
      // 不能进行有效的转换时，请返回 0
      targetNum = 0;
    }
  }
  // 4. 卡口判断
  if (targetNum > max) {
    return max;
  } else if (targetNum < min) {
    return min;
  }

  // 返回转换结果
  return targetNum;
};
```
