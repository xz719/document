// 发布-订阅模式，又称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知

// 在现实生活中，就有不少发布-订阅模式的例子，比如：微信公众号、面试等等

/* 
    在传统的发布-订阅模式中，往往是将订阅者自身的引用传入发布者中。而在JS开发中，我们一般用事件模型来替代传统的发布-订阅模式。

    发布-订阅模式有以下优点：

        * 可以广泛应用于异步编程中。在异步编程中，发布-订阅模式往往作为一种替代传入回调函数的方案。
          比如：订阅ajax请求的error、success事件。即我们无需过多关注对象在异步执行期间的内部状态，而只需要订阅我们感兴趣的事件发生点。
        
        * 发布-订阅模式可以取代对象之间硬编码的通知机制，一个对象不再显式地调用另一个对象的某个接口。
          发布-订阅模式是得两个对象以松耦合的形式联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间的通信。
          当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样，当发布者需要发生改变时，也不会影响到先前的订阅者。
          只要先前约定好的【事件名】没有变化，就可以随意修改发布者或订阅者
    
*/

// JS中的事件机制就是经典的发布-订阅模式实现
// 订阅
document.body.addEventListener('click', function () {
    alert('click!')
})
// 点击时，发送通知
document.body.click()

// ---------------------------------------------------------------

// 下面，我们一步步地实现一个简单的发布-订阅模式
// 1. 指定发布者
let observer = {}

// 2. 为发布者添加一个订阅列表（类似于关注列表），用于存放回调函数通知订阅者
observer.clientList = []

// 3. 准备一个订阅该发布者的方法
observer.subscribe = function (cb) {
    this.clientList.push(cb)
}

// 4. 当发布者发布消息时，遍历订阅列表，依次触发回调函数。
observer.publish = function () {
    for (let i = 0, callback; callback = this.clientList[i++];) {
        callback.apply(this, arguments)
    }
}

// 测试一下
// 客户1订阅
observer.subscribe(function getNote (type, source, price) {
    console.log(`客户1收到消息：【户型：${type}-房源：${source}-价格：${price}】`)
})

// 客户2订阅
observer.subscribe(function getNote (type, source, price) {
    console.log(`客户2收到消息：【户型：${type}-房源：${source}-价格：${price}】`)
})

// 发布消息
observer.publish('三室一厅', '房源1', '200000')
observer.publish('一室一厅', '房源2', '10000')

/* 
    客户1收到消息：【户型：三室一厅-房源：房源1-价格：200000】
    客户2收到消息：【户型：三室一厅-房源：房源1-价格：200000】
    客户1收到消息：【户型：一室一厅-房源：房源2-价格：10000】
    客户2收到消息：【户型：一室一厅-房源：房源2-价格：10000】
*/