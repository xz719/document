# 导读：Vue 3.0 的优化

## Vue 发展

Vue 1.x 到 Vue 2.x 最大的变动就是引入了【虚拟 DOM】。

虽然如今 Vue 2.x 的本身以及相关生态已经发展的相当完善，足以满足我们大部分的开发需求，但其仍然存在一些问题：

* 源码自身的维护性不够强
* 数据量大后带来的渲染和更新的性能问题
* 兼容性问题，存在一些想舍弃但为了兼容一直保留的鸡肋 API

同时，作者还希望给开发者带来：

* 更好的编程体验
* 更好的 TS 支持
* 更好的逻辑复用实践

所以作者希望从源码、性能和 API 三大方面来优化 Vue.js，即 Vue.js 3.0。

## Vue 3.0 做了哪些优化？

### 1. 源码优化

源码优化，也就是对 Vue.js 框架本身开发的优化，其目的在于让代码更易于开发和维护。

源码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码，最终目的是**提升自身代码的可维护性**。

### 1.1 更好的代码管理方式：monorepo

...

### 1.2 使用 TypeScript 重构源码

Vue 3.0 中抛弃了 Vue 2.0 中使用的 Flow 之后，而转向使用 TypeScript 重构了整个项目。

TS 提供了更加完善的类型检测，能够支持复杂类型的推导。

同时，TS 本身保持着一定频率的迭代，其周边生态也更好。

## 2. 性能优化

Vue 3.0 在性能优化方面做了哪些突破？

### 2.1 源码体积优化

Vue 3.0 在源码体积的减少方面做了以下工作：

* 移除一些冷漠的 feature。
* 引入 **tree-shaking** 的技术。

这里简单说一下 tree-shaking，其原理就是依赖 ES2015 模块语法的静态结构，通过**编译阶段的静态分析**，找到没有引入的模块并打上标记。

具体来说，如果你在项目中没有引入 Transition、KeepAlive 等组件，那么它们对应的代码就不会被打包，这样也就间接达到了减少项目引入的 Vue.js 包体积的问题。

### 2.2 数据劫持优化

Vue 相比于 React 而言，其一大特色就是数据是响应式的。

在 Vue 内部，要实现响应式，必须劫持数据的访问与更新。这很好理解，要在数据更新之后自动更新 DOM，那么我们就必须劫持数据的更新，在数据更新后去做一些事情，完成 DOM 的更新，而为了知道需要更新哪一片 DOM，我们需要对数据进行访问劫持，由于渲染 DOM 时访问了数据，这样在内部就形成了依赖关系。

当然，这里只是简单阐述原理，实际上的实现要复杂的多。具体可以参考下图：

[![pkqfNrj.png](https://s21.ax1x.com/2024/07/28/pkqfNrj.png)](https://imgse.com/i/pkqfNrj)

在 Vue 2.0 中，数据劫持是通过 `Object.defineProperty` 这个 API 劫持数据的 getter 和 setter 来完成的：

```js
Object.defineProperty(data, 'a', {
    get() {
        // track
    },
    set() {
        // trigger
    }
})
```

但这个 API 存在一些缺陷，其必须预先知道要拦截的属性名，即 key 是什么，所以其**无法检测到新添加的对象属性，也无法监测到属性的删除**。在 Vue 2.0 中为了弥补这一缺陷，提供了 `$set` 和 `$delete` 两个方法。

另外，这个 API 还存在一个问题，对于一个嵌套层级比较深的对象，如果需要劫持这个对象中的深层属性，那么就需要一层层地遍历这个对象，执行 `Object.defineProperty` 方法，将每一层的对象都变成响应式对象，这无疑增加了框架的性能负担。

为了解决以上两个问题，Vue 3.0 使用了 Proxy API 来完成数据劫持，其内部大致结构如下：

```js
observed = new Proxy(data, {
    get() {
        // track
    },
    set() {
        // trigger
    }
})
```

由于其劫持的是整个对象，所以其对于对象属性的增加和删除都可以检测到。

但需要注意的是，Proxy API 并不能监听到内部深层次的对象变化，因此 Vue 3.0 的处理方式是**在 getter 中去递归响应式**。这样的好处是：真正访问到的内部对象才会变成响应式，而不是无脑递归，这在很大程度上提升了性能。

后面会在响应式原理部分详细分析实现原理。

## 3. 编译优化

...

## 4. 语法优化：Composition API

将某个逻辑关注点相关的代码全都放在一个函数中，当需要修改一个功能时，不在需要在文件中跳来跳去。

## 5. 优化逻辑复用

当我们的项目变得比较复杂时，我们有时需要抽象出一些可以复用的逻辑，在 Vue 2.0 中提供了 mixin 来完成逻辑的复用。

在使用单个 mixin 时问题不大，但当我们使用多个 mixin 时，每个 mixin 都可以定义自己的 props、data，它们之间是无感的，所以很容易定义相同的变量，导致命名冲突。

对于组件而已，如果模板中使用不在当前组件中定义的遍历，那么就会不太容易知道这些变量是在哪里定义的，这就是数据来源不清晰。

但 Vue 3.0 通过 Composition API 解决了这两个问题。

## 引入 RFC
