# 需要掌握的数据结构（2）

基于上一节对数组的复习，接下来让我们复习其他线性数据结构。

## 栈和队列

在 JavaScript 中，**栈和队列的实现一般都要依赖于数组**，大家完全可以把栈和队列都看作是“特别的数组”。两者的区别在于，它们各自对数组的增删操作有着不一样的限制。

### 数组元素的增删

* shift / unshift 方法 --- 从数组的头部增删元素
  
  ```js
  const arr = [1, 2];
  arr.unshift(0);    // [0, 1, 2]
  arr.shift();     // 0
  ```

* pop / push 方法 --- 从数组的尾部增删元素
  
  ```js
  const arr = [1, 2];
  arr.push(3);  // [1, 2, 3]
  arr.pop();    // 3
  ```

* splice 方法 --- 从数组的任意位置增删元素
  
  ```js
  const arr = [1, 2];
  // 增
  arr.splice(1, 0, 3);  // [1, 3, 2]
  arr.splice(2, 0, 4);  // [1, 3, 4, 2]
  // 删
  arr.splice(1, 1);     // [1, 4, 2]
  arr.splice(2, 1);     // [1, 4]
  ```

  splice 方法第一个入参是**起始的索引值**，第二个入参表示从起始索引开始需要删除的元素个数。例如：`arr.splice(1, 1)` 指明从索引为1的元素开始，删掉1个元素，也就相当于把 `arr[1]` 给删掉了。这就是数组中删除任意位置元素的方法。至于传入两个以上参数这种用法，是用于**在删除的同时完成数组元素的新增**。而从第三个位置开始的入参，就代表着需要添加到数组里的元素的值，例如：`arr.splice(1, 1, 3)` 就是从索引为1的元素开始，删除1个元素，然后在该位置再新增一个值3。

### 栈（Stack）

栈是一种**后进先出(LIFO，Last In First Out)**的数据结构，即只允许从栈顶（数组尾部）增删元素。具体到 js 中，就是只使用 push 和 pop 方法的数组。

### 队列（Queue）

队列是一种**先进先出（FIFO，First In First Out）**的数据结构，即只能从队尾添加元素，从队头移除元素。具体到 js 中，就是只使用 push 和 shift 方法的数组。

### 链表

链表和数组相似，都是有序的列表、都是线性结构（即有且仅有一个前驱、有且仅有一个后继）。

两者的不同点在于，链表中数据单位的名称叫做【结点】，而且结点的分布在内存中可以是**离散**的。

什么叫离散呢？

数组在内存中最为关键的一个特征，就是其一般对应一段位于自身上界和下界之间的、一段连续的内存空间。元素与元素之间紧密相连。

而链表中的结点，则允许散落在内存空间中的各个角落。

在链表中，每个结点的结构都包括了两部分的内容：**数据**与**指针域**。js 中的链表，是以嵌套对象的形式来实现的：

```js
{
    // 数据
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val: 2,
        next: {...}
    }
}
```

要想访问链表中的任何一个元素，我们都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置：

![alt text](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981d8c74866d4aefb8b695c9e4ed0e1e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp)

#### 链表结点的创建

我们可以编写一个构造函数用于创建链表结点：

```js
function ListNode (val) {
    this.val = val;
    this.next = null;
}

// 创建节点，链接后继
const node1 = new ListNode(1);
node1.next = new ListNode(2);
```

#### 链表元素的添加

结合前面的学习，我们已经知道，链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。

先来说说添加，直接在尾部添加结点相对比较简单，我们改变一个 next 指针就行。

需要大家引起重视的是另一种添加操作：**如何在两个结点间插入一个结点？**，这是链表中的一个关键点。

```js
// 目标结点
const node3 = new ListNode(3);

// 添加
node3.next = node1.next;
node1.next = node3;
```

#### 链表元素的删除

延续前面的思路：

```js
// 删除 node3
const target = node1.next
node1.next = target.next;
```

### 链表和数组的辨析

在大多数的计算机语言中，数组都对应着一段连续的内存。如果我们想要在任意位置删除一个元素，那么该位置往后的所有元素，都需要往前挪一个位置；相应地，如果要在任意位置新增一个元素，那么该位置往后的所有元素也都要往后挪一个位置，这种操作的时间复杂度是 O(n)。

但 JS 中不一定。

JS比较特别。如果我们在一个数组中只定义了一种类型的元素，比如：

```js
const arr = [1,2,3,4]
```

它是一个纯数字数组，那么对应的确实是连续内存。

但如果我们定义了不同类型的元素：

```js
const arr = ['haha', 1, {a:1}]
```

它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。

即，js 数组未必是真正的数组。

相对于数组来说，链表有一个明显的优点：添加和删除元素都不需要挪动多余的元素。

#### 高效的增删操作

在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，即 O(1)。

#### 复杂的访问操作

但是链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高，即时间复杂度为 O(n)。

但在数组中，可以通过索引直接访问结点，其时间复杂度仅为 O(1)。这也是数组的优势。