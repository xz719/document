# 4. Vite 中静态资源的动态访问

在用 vite 打包的项目中，一般通过路径访问静态资源是没问题的，比如：

```html
<img src="./xxxxxx.jpg" />
```

```css
.demo {
    background: url("./xxxxxx.jpg")
}
```

以这种形式访问的静态资源，在打包后是没问题的（项目运行时，浏览器里面就是打包后的结果）。

但如果我们用动态的形式来进行访问：

```vue
<div 
    class="container" 
    :style="{
        backgroundImage: `url(${path})`,
    }"
></div>

<script setup>
const path = ref("./assets/xxxxxx.jpg")
</script>
```

在打包放到浏览器中后，发现报错，找不到这张图片，而当我们查看打包结果时，会发现打包结果中根本就没有这张图片。

这实际上是因为，vite 并不知道我们依赖了这张图片，既然没有依赖，就不会生成到打包结果。

而前面之所以能够使用，是因为 vite 会对静态资源进行自动的识别和处理，包括：

1. 标签的路径
2. CSS中的路径
3. 动态导入语句中的路径
4. URL构造函数中的路径

当 vite 识别到静态资源时，会将目标与当前文件形成依赖，然后就会将所依赖的文件生成到打包结果中，在生成到打包结果的同时，还会为其加上一个**文件指纹**(具体来说就是每个文件后面会带上一个hash值)。

所以，我们如果要动态访问静态资源，就要满足两个条件：

1. 形成依赖
2. 访问打包结果中的路径而不是源代码中的路径

要满足这两个条件，有如下几种方法：

## 4.1 通过 `import` 引入

可以通过 `import` 引入的方式对文件形成依赖，且导入之后会直接拿到打包后的路径

```js
import img1 from './assets/xxxxxx.jpg'
```

但对于图片较多的情况，多次导入十分麻烦，并不太适用。

## 4.2 动态导入

我们可以选择用下面的动态导入的方式形成依赖：

```js
const val = ref("")

val.value = "xxxxxx"

import(`./assets/${val}.jpg`)
```

但是这种方式也存在问题，首先在打包时，代码是不会执行的，最终代码是在浏览器中执行，既然不执行，那么 vite 就不知道 `val` 是多少，那么它怎么知道依赖的是哪个文件呢？

如果我们去看最终的打包结果，就会知道，vite 的处理就是将 `./assets` 下的所有文件全部生成到打包结果中。这也就是为什么动态导入时，必须要求有静态的部分如 `./assets`，因为如果是全动态的，那么 vite 就完全不知道依赖的是哪个文件了！

虽然有问题，但还是来继续说说这个方法。

动态导入后，我们可以通过 `.then` 来拿到打包后的路径：

```js
const val = ref("")

val.value = "xxxxxx"

const path = ref("")
import(`./assets/${val}.jpg`).then((res) => {
    // 获取打包后的路径
    path.value = res.default
})
```

这种方法问题就是上面说到的，会将某一目录下的所有文件都形成依赖并加入到打包结果中，且每个文件都会有一个对应的 js 文件，这样最终会导致网络请求的增加。

## 4.3 URL

前面说到过，vite 能够识别到 URL 构造对象中传递的路径，那么我们就可以用下面的方式：

```js
const val = ref("");

val.value = "xxxxxx";

const path = ref("");
const url = new URL(`./assets/${val}.jpg`, import.meta.url);
path.value = url.pathname;
```

采用这种方式，虽然它也会将静态路径下的所有文件形成依赖并加入打包结果，但它不会为每一文件都生成一个对应的 js 文件，网络请求相对少一些。
