# JS 深浅拷贝

## 1. 为什么会出现深浅拷贝？

实质上是由于 JS 对【基本类型】和【引用类型】的处理不同。

简单来说，就是 JS 会把基本数据类型存储在栈内存中，当把一个值为基本数据类型的变量复制到另一个新变量时，仅仅是创建一个新值，然后将该值赋到为这个新变量分配的内存空间中，这个新变量和原来的变量可以参与任何操作而互不影响。而对于引用类型，JS 会将它们的实际值存储到堆内存中，栈中仅仅存储它们的实际值在堆中的地址（引用），而 JS 不允许我们直接操作栈内存中的地址，也就是不能操作对象的堆内存空间，所以，我们对对象的操作都只是在操作它的引用而已。因此，当我们将一个引用类型的变量复制到另一个新变量时，就会出现两种情况：

1. 仅仅**复制了引用类型实际值的引用**，而不是在堆中重新开辟一个新的存储空间 --- 浅拷贝
2. 在堆中重新**开辟了一个新的存储空间**，然后将这个存储空间的引用赋给新变量 --- 深拷贝

❗ 当我们谈论深浅拷贝时，往往是针对于多层级数组或对象时存在的情况！

下面给出一个例子来帮助理解深浅拷贝：

[理解深浅拷贝](./tests/sample.js)

## 2. 如何实现深浅拷贝？

### 2.1 浅拷贝

浅拷贝有两种情况，一种是之间用赋值操作直接将引用对象赋给另一个变量；另一种是仅仅拷贝了多层复合数组或对象的第一层，即【首层浅拷贝】。

第一种情况根本无需我们实现，赋值操作本身就可以做到，我们主要关注的是第二种情况。

#### 2.1.1 利用数组的 `concat` 方法

[利用数组 `concat` 方法实现数组首层浅拷贝](./tests/shallow/concat.js)

#### 2.1.2 利用数组的 `slice` 方法

[利用数组 `slice` 方法实现数组首层浅拷贝](./tests/shallow/slice.js)

#### 2.1.3 利用 `Object.assign()`

`Object.assign()` 方法只适用于对象，可以实现对象的合并，语法：

`Object.assign(target, source_1, ..., source_n)`

`Object.assign()` 方法会将 `source` 里面的可枚举属性复制到 `target`，复制的是属性值，如果属性值是一个引用类型，那么复制的是**引用地址**，因此也属于浅拷贝。

[利用 `Object.assign()` 方法实现复合对象首层浅拷贝](./tests/shallow/assign.js)

#### 2.1.4 利用扩展运算符 `...`

扩展运算符的方式既可以浅拷贝数组（上面最开始的例子），也可以浅拷贝对象：

[利用扩展运算符实现数组或对象的首层浅拷贝](./tests/shallow/spreadOperator.js)

### 2.2 深拷贝

前面说过，深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了，只要进行了深拷贝，新变量与旧变量之间老死不相往来，谁也不会影响谁。

#### 2.2.1 利用 JSON 对象的 `parse` 和 `stringify` 方法

`JSON.stringify()` 方法会把对象或数组先转化为字符串，字符串就已经不代表任何空间地址了，就是单纯的字符串，而 `JSON.parse()` 方法把字符串解析成新对象或数组，这样，对象或数组的每个层级都会在堆内存中开辟新空间。

[利用 JSON 对象的 `parse` 和 `stringify` 方法实现数组和对象的深拷贝](./tests/deep/JSON%20parse%20stringify.js)

但是需要注意，这个方法在某些情况下是不适用的，比如下面这样的一个对象就不适用：

```js
const originObj = {
  name:'with func',
  sayHello:function(){
    console.log('Hello');
  }
}
console.log(originObj); // { name: "with func", sayHello: ƒ }
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj);  // { name: "with func" }

```

为什么？

> 因为使用 `JSON.parse/stringify` 在遇到:
>
> 1. 函数
> 2. `undefined`
> 3. `Symbol`
> 4. 正则
> 5. `Date`类型（会被转成时间字符串形式，）
>
> 时会丢失，无法对上述几种情况进行正常复制，所以当遇到要复制的对象中包含这些内容的时候，就不能使用 `JSON.parse/stringify` 进行深拷贝了

#### 2.2.2 利用递归

如果不想用 JSON 的两个方法，也不想用第三方库的话，我们实际上可以自己利用递归实现一个深拷贝的方法：

[手写递归实现深拷贝](./tests/deep/deepClone.js)

#### 2.2.3 利用第三方库

有一些第三方库中实现了深拷贝的方法，比如：[lodash](https://www.lodashjs.com/docs/lodash.cloneDeep#_clonedeepvalue)

## 总结

JS 的浅拷贝与深拷贝主要是作用于**多层级数组或对象**中。

浅拷贝是只复制创建数组或对象的第一层，其他层级和原数组或对象拥有相同地址值，因此修改浅拷贝的数组或对象的深层的数值就会影响原数组或对象的值。而深拷贝则是拷贝一个全新的数组或对象，每一个层级都在堆内存中开辟了新的空间，和原数组或对象相互不影响。

具体到实现：

1. 赋值运算符 = 实现的是浅拷贝，只拷贝对象的引用值；
2. JS 中数组和对象自带的拷贝方法都是【首层浅拷贝】；
3. `JSON.parse` 和 `JSON.stringify` 实现的是深拷贝，但是**对目标对象有要求**！
4. 若想真正意义上的深拷贝，请**递归**。
