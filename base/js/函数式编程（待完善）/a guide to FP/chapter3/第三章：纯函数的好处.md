# a guide to functional programming

## 第三章：纯函数以及其好处

首先需要强调一遍纯函数的概念：

> 在程序设计中，若一个函数符合以下条件，那么这个函数就被称为纯函数：
>
> * 此函数在接收相同的输入值时，需产生相同的输出
> * 函数的输出与除输入值以外的其它隐藏信息或状态无关，也和由I/O设备产生的外部输出无关
> * 该函数不能有语义上可观察的函数副作用，诸如：触发事件、使输出设备输出，或是更改输出值以外变量的内容等

而纯函数与非纯函数的最好例子就是数组方法中的 `slice` 和 `splice`

[slice与splice](./tests/pure.js)

在函数式编程环境中，我们反感这种会改变外部数据的函数，我们追求的是可靠的、对于相同的输入能够得到相同输出的函数，而不是像 `splice` 这种每次调用都会把数据弄乱的函数。

如果对于纯函数不熟悉，可以参考[纯函数](../../../函数式编程/纯函数.md)

这里我们不再重复解释说明纯函数的基本定义，而是深入探讨一下【副作用】。

### 副作用？

副作用是什么？

> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互

副作用可能包括：更改文件系统、发送http请求、log等等，这里不再列举，概括地来讲，只要是与函数外部发生的交互行为就是副作用。

既然这样，那无副作用的编程似乎是不可能的。但函数式编程的哲学就在于此，其**假定副作用是造成不正当行为的主要原因**，但并不是要禁止一切副作用，而是要**让副作用在可控范围内发生**。（后续我们会学习如何控制它们）

我们都知道

> 副作用会让函数变得不纯

为什么？

从定义上来讲，纯函数必须要能够面对相同的输入时，得到相同的输出，而一旦函数中存在副作用，即需要与函数的外部进行交互，那么这一点就无法保证了！

但为什么我们需要一直维护这一原则呢？（即相同输入对应相同输出的原则）

### 为什么要求纯函数面对相同输入应得到相同输出？

在数学中，函数是指：

> 不同数值之间的特殊关系，每一个输入值返回且只返回一个输出值。多个输入值可以对应同一个输出值，但一个输入值只能对应一个输出值

如图就是一个合法的函数：

![函数](./images/function-sets.gif)

相反，下面就不是一个合法的函数关系：

![非函数](./images/relation-not-function.gif)

进一步地，函数实际上可以被描述为集合映射：

* 其可以是**输入输出对**的形式：`[(1, 2), (3, 6), (5, 10)]`
* 或者是**表**的形式：
    | 输入 | 输出 |
    | ---  | --- |
    | 1    | 2   |
    | 2    | 4   |
    | 3    | 6   |
    | 4    | 8   |
    | 5    | 10  |

甚至是一个**曲线图**：

![函数曲线图](./images/fn_graph.png)

实际上，当函数中的输入直接指明了输出，那么就不需要实现函数中的具体细节了，因为函数仅仅是输入到输出的映射而已，用字典对象的方式直接实现即可：

[用字典对象实现函数](./tests/alphabet.js)

虽然在实际开发中，这种穷举的方式太过低效，我们不可能真的这样实现，但其实际上反应了一种思考函数的方式，即**值到值之间的映射**。

那么如何一个函数有多个参数呢？目前，我们可以将这些参数打包放到一个数组里，或者直接将函数中的 arguments 对象看作输入。等到后续学习了【柯里化】之后，我们就可以直接为函数在数学上的定义进行建模了！

所以，为什么我们要坚持纯函数的面对相同输入有相同输出的原则？因为纯函数实际上就是数学上的函数，其反应的是【值与值之间的映射关系】，且是函数式编程的理论基础，且坚持这一原则会带来许多好处。

### 坚持纯函数的好处

#### 1. 可缓存性（Cacheable）

可缓存性，指**纯函数总能够根据输入来做缓存**。参考[可缓存性](./tests/cacheable.js)

#### 2. 可移植性（Portable）/ 自文档化（Self-Documenting）

可移植性或者说自文档化，指**纯函数本身是自给自足的**，其所需要的所有资源都可以简单地获取到。参考[可移植性/自文档化](./tests/portable.js)

这种自给自足的好处在于：

* 纯函数中的依赖很明确，其不会依赖于函数外部的状态，更加易于观察和理解
* 纯函数通过强迫“注入”依赖，或者将这些依赖作为参数传递，使得应用更具灵活性

在 js 中，可移植性意味着可以将函数序列化并通过 socket 发送，也意味着代码能够在 web workers 中运行。

在传统的命令式编程中，典型的方法和过程都深深植根于它们所在的环境，纯函数则不同，**它与所处的环境无关**，只要我们愿意，我们可以在任何地方运行它。

#### 3. 可测试性（Testable）

在纯函数的测试过程中，我们不需要每次测试之前都进行配置，测试完成后再断言状态，而是仅仅需要简单地给函数一个输入，然后断言输出即可。

#### 4. 合理性（Reasonable）

合理性主要有两方面：（参考[合理性](./tests/reasonable.js)）

* 引用透明性（referential transparency）
  
  > 如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。

  由于**纯函数中始终仅用其输入来计算输出，所以其始终保持引用透明性**

* 在引用透明的前提下，我们可以利用【等式推导】来分析、重构代码

#### 5. 并行代码（Parallel Code）

由于纯函数并不依赖函数外部的状态，所以纯函数根本不需要访问共享的内存，所以：

* 我们可以并行运行任意纯函数
* 纯函数不会因为副作用而进入竞争态（race condition）

### 下一章

现在我们已经知道了什么是纯函数，以及使用纯函数的原因。但如果我们想要以纯函数的形式编写所有函数，在不借助任何工具的情况下，是比较困难的，因为我们需要到处传递参数来达成目的，同时，我们还被禁止使用状态和作用。所以，下一章我们将学习一个新工具【柯里化】，来帮助我们编写纯函数。
