# 纯函数

`纯函数 (Pure Function)` 是 `函数式编程` 中一个非常重要的概念，维基百科中对纯函数的定义如下：

> 在程序设计中，若一个函数符合以下条件，那么这个函数就被称为纯函数：
>
> * 此函数在接收相同的输入值时，需产生相同的输出
> * 函数的输出与除输入值以外的其它隐藏信息或状态无关，也和由I/O设备产生的外部输出无关
> * 该函数不能有语义上可观察的函数副作用，诸如：触发事件、使输出设备输出，或是更改输出值以外变量的内容等

纯函数是一个**定义**，对于一个纯函数，执行它**不会产生不可预料的行为，也不会对外部产生影响**。

简单来说，如果一个函数是纯函数，其必须符合两个条件：

* 返回结果只依赖于其**参数**
* 在执行过程中没有【副作用】

什么是【副作用】？

## 副作用

> 函数副作用，指当调用函数时，除了返回函数值之外，还对**主调用函数**产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。

当然，副作用并不只包括修改外部变量的值，在实际开发中，有很多操作都会产生副作用，例如：

* 调用 DOM API 修改了页面的内容
* 发送 `ajax` 请求获取数据
* 调用 `window.reload` 刷新浏览器
* 调用 `console.log()` 输出某些数据到控制台
* 调用 `Date.now()` 或 `Math.Radom()` 等不纯的方法
* ...

函数的副作用会给程序设计带来一些不必要的麻烦，**使得程序中的错误难以追溯**，因此，严格的函数式编程中要求函数必须是无副作用的。

了解了副作用的定义后，我们可以进一步扩展纯函数的定义：

> 纯函数中，输入输出数据流全是**显式（Explicit）**的。
>
> 显式（Explicit）的意思是，函数与外界交换数据只有一个**唯一渠道**就是**参数**和**返回值**。函数从函数外部接受的所有输入信息都通过参数传递到该函数内部。函数输出到函数外部的所有信息都通过返回值传递到该函数外部。

接下来，来对纯函数的两个条件进行详细的说明。

## 条件一：函数的返回结果只依赖于它的参数

例1：

```javascript
const a = 1
const foo = (b) => a + b
foo(2) // => 3
```

虽然这里的 a 是外部常量，而且我们在函数中也没有改变它的值，但是 foo 函数仍然不属于纯函数，因为其返回值并不是只依赖于他的参数 b，还依赖了常量 a。

当我们在这里调用 foo 时，a 的确是一个值为2的常量，但是我们无法保证在其他地方调用 foo 时，a 仍然是值为2的常量，即存在不可控的情况！

下面来看第二个例子：

```js
const a = 1
const foo = (x, y) => x + y
foo(a, 2)
```

可以看到，这里的 foo 函数，其返回值就是完全只依赖其接收到的参数，并不存在不可控的情况。因此这个 foo 函数是一个纯函数。

## 条件二：函数执行过程中没有副作用

如上面所说，副作用，就是指在函数的执行过程中，对外部(即调用函数的作用域)产生了可被观测的影响。

这样的定义难免有些抽象，下面看一个简单的例子：

```js
const counter = { x: 1 }
const foo = (obj, b) => {
  obj.x = 2
  return obj.x + b
}

foo(counter, 2) // => 4
counter.x // => 2
```

这里可以看到，我们向函数 foo 中传入了一个对象 obj 的引用，然后在 foo 函数中，修改了 obj 身上 x 属性的值！这意味着，无论我们在哪里调用这个函数，我们都修改了外部作用域中变量的值，即产生了副作用。所以 foo 函数不是一个纯函数。

而如果我们将上面例子中的 `obj.x = 2` 去掉，则 foo 函数中没有修改外部变量的值，且其返回值也是完全仅依赖于其接收到的参数，因此，此时的 foo 是一个纯函数。

## 纯函数案例

```js
// 非纯函数，返回结果依赖于外部变量
let min = 18
function lessThen18 (number) {
    return number < min
}

// 纯函数，但存在硬编码的问题，可以通过函数柯里化解决
function lessThen18Pure (number) {
    const min = 18
    return number < min
}

// 柯里化
function lessThen (limit) {
    return function (number) {
        return number < limit
    }
}

const lessThen18 = lessThen(18)
console.log(lessThen18(20))
```

在某些场景中，使用柯里化能够帮助我们将非纯函数改造为纯函数
