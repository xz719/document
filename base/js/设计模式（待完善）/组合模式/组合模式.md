# JS 设计模式

## 组合模式

组合模式：又叫 “部分整体” 模式，将对象组合成**树形结构**，以表示 “部分-整体” 的层次结构。通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。

### 1. 了解组合模式

组合模式有两种结构：

1. 组合对象 --- 组合对象中都实现了一个用来获得子对象的方法
2. 叶对象

可以用如下的树形结构来描述组合模式：

[![pF1ZuGV.png](https://s11.ax1x.com/2024/02/06/pF1ZuGV.png)](https://imgse.com/i/pF1ZuGV)

组合模式有如下特点：

* 透明性 --- 组合对象和叶对象接口保持统一，外部调用时无需区分。（但需要注意，如文件目录的例子，文件（叶对象）下不可再添加文件，因此需在文件类的 add() 方法中抛出异常，以作提醒。）
* 自上而下的的请求流向，从组合对象传递给叶对象；
* 调用顶层对象，会自行遍历其下的叶对象执行。

下面给出一个组合模式的例子：

[利用组合模式实现文件目录](./demo.js)

### 2. 组合模式的优缺点以及适用场景

组合模式的**优点**在于：

* 组合模式忽略组合对象和单一对象之间的差别，对外保持了接口使用的一致性
* 解耦了调用者与复杂元素之间的联系，使得处理方式更加简单

但其同样存在一些**缺点**：

* 组合对象与叶对象接口保持一致，难以区分，只有在运行时才能分辨出来
* 包裹的对象创建太多，会增加内存负担，影响程序性能

那么，组合模式适用于什么场景呢？

1. **优化处理递归或分级数据结构**（文件系统 - 目录文件管理）；
2. **与其它设计模式联用**，如与命令模式联用实现 “宏命令”。
3. **表示对象的部分-整体层次结构**。组合模式可以方便地构造一棵树来表示对象的【部分 - 整体】结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，**只需要通过请求树的最顶层对象，便能对整棵树做统一的操作**。在组合模式 中增加和删除树的节点非常方便，并且符合开放-封闭原则。
4. **客户希望统一对待树中的所有对象**。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆if、else语句来分别处理它们。**组合对象和叶对象会各自做自己正确的事情**，这是组合模式最重要的能力。

合理使用组合模式，能够大大简化代码！

但是，在使用组合模式时，有一些需要注意的地方。

### 3. 注意事项

1. **组合不是继承，组合对象与叶对象之间并不是父子对象关系**！

   组合模式不是父子关系，它是一种【 HAS-A（聚合）】的关系，调用组合对象时，会将请求委托给它所包含的所有叶对象。组合对象与叶对象能够合作的关键，是它们**对外保持统一接口**，而不是叶对象继承树对象的属性方法

   此外，也要保证用一致的方式对待树中的每个叶对象，即叶对象属于同一类，不需要过多特殊的额外操作

2. **叶对象操作保持一致性**

   叶对象除了与树对象接口一致外，操作也必须保持一致性。一片叶子只能生在一颗树上。调用顶层对象时，每个叶对象只能接收一次请求，一个叶对象不能从属多个树对象。

3. **叶对象也可以实现冒泡传递**

   请求不仅仅可以由组合对象向叶对象传递，如果想逆转传递过程，需在叶对象中保留对组合对象的引用，冒泡传递给组合对象处理。

4. **组合模式不只是简单的子集遍历**

   调用树中某一对象的接口方法时，如果该对象是组合对象，则会将请求传递给叶对象，由叶对象执行方法，以此类推。不同于迭代器模式，迭代器模式遍历并不会做请求传导。

5. **可以利用【职责链模式】提高组合模式性能**

   在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。

   有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助【职责链模式】。职责链模式一般需要我们手动去设置链条，但**在组合模式中，父对象和子对象之间实际上形成了天然的职责链**。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。
